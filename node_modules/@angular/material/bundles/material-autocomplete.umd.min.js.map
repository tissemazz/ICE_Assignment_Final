{"version":3,"sources":["src/material/material-autocomplete.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","autocomplete","tslib","cdk","a11y","coercion","core","rxjs","common","overlay","bidi","keycodes","platform","portal","scrolling","forms","formField","operators","this","core$1","_uniqueAutocompleteIdCounter","MatAutocompleteSelectedEvent","source","option","_MatAutocompleteMixinBase","mixinDisableRipple","MatAutocompleteBase","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS","InjectionToken","providedIn","MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY","autoActiveFirstOption","MatAutocomplete","_super","_changeDetectorRef","_elementRef","defaults","_this","call","_activeOptionChanges","Subscription","EMPTY","showPanel","_isOpen","displayWith","optionSelected","EventEmitter","opened","closed","optionActivated","_classList","id","_autoActiveFirstOption","__extends","Object","defineProperty","prototype","get","enumerable","configurable","set","value","coerceBooleanProperty","length","split","reduce","classList","className","trim","_setVisibilityClasses","nativeElement","ngAfterContentInit","_keyManager","ActiveDescendantKeyManager","options","withWrap","change","subscribe","index","emit","toArray","_setVisibility","ngOnDestroy","unsubscribe","_setScrollTop","scrollTop","panel","_getScrollTop","markForCheck","_emitSelectEvent","event","decorators","type","Component","args","selector","template","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","exportAs","inputs","host","class","providers","provide","MAT_OPTION_PARENT_COMPONENT","useExisting","styles","ctorParameters","ChangeDetectorRef","ElementRef","undefined","Inject","propDecorators","ViewChild","TemplateRef","static","ContentChildren","MatOption","descendants","optionGroups","MatOptgroup","Input","panelWidth","Output","MatAutocompleteOrigin","elementRef","Directive","MAT_AUTOCOMPLETE_SCROLL_STRATEGY","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY","scrollStrategies","reposition","MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER","deps","Overlay","useFactory","MAT_AUTOCOMPLETE_VALUE_ACCESSOR","NG_VALUE_ACCESSOR","forwardRef","MatAutocompleteTrigger","multi","getMatAutocompleteMissingPanelError","Error","_element","_overlay","_viewContainerRef","_zone","scrollStrategy","_dir","_formField","_document","_viewportRuler","_componentDestroyed","_autocompleteDisabled","_manuallyFloatingLabel","_viewportSubscription","_canOpenOnNextFocus","_closeKeyEventStream","Subject","_windowBlurHandler","activeElement","panelOpen","_onChange","_onTouched","position","autocompleteAttribute","_overlayAttached","optionSelections","defer","merge","apply","__spread","map","onSelectionChange","onStable","asObservable","pipe","take","switchMap","_scrollStrategy","ngAfterViewInit","window","runOutsideAngular","addEventListener","_supportsShadowDom","element","rootNode","getRootNode","_isInsideShadowRoot","ShadowRoot","ngOnChanges","changes","_positionStrategy","_setStrategyPositions","_overlayRef","updatePosition","removeEventListener","_destroyPanel","complete","openPanel","_attachOverlay","_floatLabel","closePanel","_resetLabel","hasAttached","detach","_closingActionsSubscription","detectChanges","tabOut","filter","_getOutsideClickStream","detachments","of","MatOptionSelectionChange","activeItem","fromEvent","clickTarget","composedPath","target","contains","overlayElement","writeValue","Promise","resolve","then","_setTriggerValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","_handleKeydown","keyCode","ESCAPE","preventDefault","activeOption","ENTER","_selectViaInteraction","_resetActiveItem","prevActiveItem","isArrowKey","UP_ARROW","DOWN_ARROW","TAB","onKeydown","_canOpen","_scrollToOption","_handleInput","parseFloat","_previousValue","_handleFocus","shouldAnimate","floatLabel","_animateAndLockLabel","activeItemIndex","labelCount","_countGroupLabelsBeforeOption","newScrollPosition","_getOptionScrollPosition","_subscribeToClosingActions","firstStable","optionChanges","tap","reapplyLastPosition","delay","wasOpen","panelClosingActions","_setValueAndClose","dispose","toDisplay","inputValue","_control","_clearPreviousSelectedOption","focus","skip","forEach","selected","deselect","overlayRef","setOrigin","_getConnectedElement","updateSize","width","_getPanelWidth","_portal","TemplatePortal","create","_getOverlayConfig","keydownEvents","altKey","next","stopPropagation","attach","OverlayConfig","positionStrategy","_getOverlayPosition","direction","strategy","flexibleConnectedTo","withFlexibleDimensions","withPush","belowPosition","originX","originY","overlayX","overlayY","abovePosition","panelClass","withPositions","connectedTo","getConnectedOverlayOrigin","_getHostWidth","getBoundingClientRect","setActiveItem","readOnly","[attr.autocomplete]","[attr.role]","[attr.aria-autocomplete]","[attr.aria-activedescendant]","[attr.aria-expanded]","[attr.aria-owns]","[attr.aria-haspopup]","(focusin)","(blur)","(input)","(keydown)","ViewContainerRef","NgZone","Directionality","Optional","MatFormField","Host","DOCUMENT","ViewportRuler","autocompleteDisabled","MatAutocompleteModule","NgModule","imports","MatOptionModule","OverlayModule","MatCommonModule","CommonModule","declarations","AUTOCOMPLETE_OPTION_HEIGHT","AUTOCOMPLETE_PANEL_HEIGHT"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/a11y'), require('@angular/cdk/coercion'), require('@angular/core'), require('@angular/material/core'), require('rxjs'), require('@angular/common'), require('@angular/cdk/overlay'), require('@angular/cdk/bidi'), require('@angular/cdk/keycodes'), require('@angular/cdk/platform'), require('@angular/cdk/portal'), require('@angular/cdk/scrolling'), require('@angular/forms'), require('@angular/material/form-field'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/autocomplete', ['exports', 'tslib', '@angular/cdk/a11y', '@angular/cdk/coercion', '@angular/core', '@angular/material/core', 'rxjs', '@angular/common', '@angular/cdk/overlay', '@angular/cdk/bidi', '@angular/cdk/keycodes', '@angular/cdk/platform', '@angular/cdk/portal', '@angular/cdk/scrolling', '@angular/forms', '@angular/material/form-field', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.autocomplete = {}), global.tslib, global.ng.cdk.a11y, global.ng.cdk.coercion, global.ng.core, global.ng.material.core, global.rxjs, global.ng.common, global.ng.cdk.overlay, global.ng.cdk.bidi, global.ng.cdk.keycodes, global.ng.cdk.platform, global.ng.cdk.portal, global.ng.cdk.scrolling, global.ng.forms, global.ng.material.formField, global.rxjs.operators));\n}(this, (function (exports, tslib, a11y, coercion, core, core$1, rxjs, common, overlay, bidi, keycodes, platform, portal, scrolling, forms, formField, operators) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Autocomplete IDs need to be unique across components, so this counter exists outside of\n     * the component definition.\n     */\n    var _uniqueAutocompleteIdCounter = 0;\n    /** Event object that is emitted when an autocomplete option is selected. */\n    var MatAutocompleteSelectedEvent = /** @class */ (function () {\n        function MatAutocompleteSelectedEvent(\n        /** Reference to the autocomplete panel that emitted the event. */\n        source, \n        /** Option that was selected. */\n        option) {\n            this.source = source;\n            this.option = option;\n        }\n        return MatAutocompleteSelectedEvent;\n    }());\n    // Boilerplate for applying mixins to MatAutocomplete.\n    /** @docs-private */\n    var MatAutocompleteBase = /** @class */ (function () {\n        function MatAutocompleteBase() {\n        }\n        return MatAutocompleteBase;\n    }());\n    var _MatAutocompleteMixinBase = core$1.mixinDisableRipple(MatAutocompleteBase);\n    /** Injection token to be used to override the default options for `mat-autocomplete`. */\n    var MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new core.InjectionToken('mat-autocomplete-default-options', {\n        providedIn: 'root',\n        factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\n    });\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\n        return { autoActiveFirstOption: false };\n    }\n    var MatAutocomplete = /** @class */ (function (_super) {\n        tslib.__extends(MatAutocomplete, _super);\n        function MatAutocomplete(_changeDetectorRef, _elementRef, defaults) {\n            var _this = _super.call(this) || this;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._elementRef = _elementRef;\n            _this._activeOptionChanges = rxjs.Subscription.EMPTY;\n            /** Whether the autocomplete panel should be visible, depending on option length. */\n            _this.showPanel = false;\n            _this._isOpen = false;\n            /** Function that maps an option's control value to its display value in the trigger. */\n            _this.displayWith = null;\n            /** Event that is emitted whenever an option from the list is selected. */\n            _this.optionSelected = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is opened. */\n            _this.opened = new core.EventEmitter();\n            /** Event that is emitted when the autocomplete panel is closed. */\n            _this.closed = new core.EventEmitter();\n            /** Emits whenever an option is activated using the keyboard. */\n            _this.optionActivated = new core.EventEmitter();\n            _this._classList = {};\n            /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\n            _this.id = \"mat-autocomplete-\" + _uniqueAutocompleteIdCounter++;\n            _this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\n            return _this;\n        }\n        Object.defineProperty(MatAutocomplete.prototype, \"isOpen\", {\n            /** Whether the autocomplete panel is open. */\n            get: function () { return this._isOpen && this.showPanel; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"autoActiveFirstOption\", {\n            /**\n             * Whether the first option should be highlighted when the autocomplete panel is opened.\n             * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\n             */\n            get: function () { return this._autoActiveFirstOption; },\n            set: function (value) {\n                this._autoActiveFirstOption = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocomplete.prototype, \"classList\", {\n            /**\n             * Takes classes set on the host mat-autocomplete element and applies them to the panel\n             * inside the overlay container to allow for easy styling.\n             */\n            set: function (value) {\n                if (value && value.length) {\n                    this._classList = value.split(' ').reduce(function (classList, className) {\n                        classList[className.trim()] = true;\n                        return classList;\n                    }, {});\n                }\n                else {\n                    this._classList = {};\n                }\n                this._setVisibilityClasses(this._classList);\n                this._elementRef.nativeElement.className = '';\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocomplete.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._keyManager = new a11y.ActiveDescendantKeyManager(this.options).withWrap();\n            this._activeOptionChanges = this._keyManager.change.subscribe(function (index) {\n                _this.optionActivated.emit({ source: _this, option: _this.options.toArray()[index] || null });\n            });\n            // Set the initial visibility state.\n            this._setVisibility();\n        };\n        MatAutocomplete.prototype.ngOnDestroy = function () {\n            this._activeOptionChanges.unsubscribe();\n        };\n        /**\n         * Sets the panel scrollTop. This allows us to manually scroll to display options\n         * above or below the fold, as they are not actually being focused when active.\n         */\n        MatAutocomplete.prototype._setScrollTop = function (scrollTop) {\n            if (this.panel) {\n                this.panel.nativeElement.scrollTop = scrollTop;\n            }\n        };\n        /** Returns the panel's scrollTop. */\n        MatAutocomplete.prototype._getScrollTop = function () {\n            return this.panel ? this.panel.nativeElement.scrollTop : 0;\n        };\n        /** Panel should hide itself when the option list is empty. */\n        MatAutocomplete.prototype._setVisibility = function () {\n            this.showPanel = !!this.options.length;\n            this._setVisibilityClasses(this._classList);\n            this._changeDetectorRef.markForCheck();\n        };\n        /** Emits the `select` event. */\n        MatAutocomplete.prototype._emitSelectEvent = function (option) {\n            var event = new MatAutocompleteSelectedEvent(this, option);\n            this.optionSelected.emit(event);\n        };\n        /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\n        MatAutocomplete.prototype._setVisibilityClasses = function (classList) {\n            classList['mat-autocomplete-visible'] = this.showPanel;\n            classList['mat-autocomplete-hidden'] = !this.showPanel;\n        };\n        MatAutocomplete.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-autocomplete',\n                        template: \"<ng-template>\\n  <div class=\\\"mat-autocomplete-panel\\\" role=\\\"listbox\\\" [id]=\\\"id\\\" [ngClass]=\\\"_classList\\\" #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\",\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        exportAs: 'matAutocomplete',\n                        inputs: ['disableRipple'],\n                        host: {\n                            'class': 'mat-autocomplete'\n                        },\n                        providers: [\n                            { provide: core$1.MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\n                        ],\n                        styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatAutocomplete.ctorParameters = function () { return [\n            { type: core.ChangeDetectorRef },\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatAutocomplete.propDecorators = {\n            template: [{ type: core.ViewChild, args: [core.TemplateRef, { static: true },] }],\n            panel: [{ type: core.ViewChild, args: ['panel',] }],\n            options: [{ type: core.ContentChildren, args: [core$1.MatOption, { descendants: true },] }],\n            optionGroups: [{ type: core.ContentChildren, args: [core$1.MatOptgroup, { descendants: true },] }],\n            displayWith: [{ type: core.Input }],\n            autoActiveFirstOption: [{ type: core.Input }],\n            panelWidth: [{ type: core.Input }],\n            optionSelected: [{ type: core.Output }],\n            opened: [{ type: core.Output }],\n            closed: [{ type: core.Output }],\n            optionActivated: [{ type: core.Output }],\n            classList: [{ type: core.Input, args: ['class',] }]\n        };\n        return MatAutocomplete;\n    }(_MatAutocompleteMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /**\n     * Directive applied to an element to make it usable\n     * as a connection point for an autocomplete panel.\n     */\n    var MatAutocompleteOrigin = /** @class */ (function () {\n        function MatAutocompleteOrigin(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n        MatAutocompleteOrigin.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matAutocompleteOrigin]',\n                        exportAs: 'matAutocompleteOrigin',\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteOrigin.ctorParameters = function () { return [\n            { type: core.ElementRef }\n        ]; };\n        return MatAutocompleteOrigin;\n    }());\n\n    /**\n     * The following style constants are necessary to save here in order\n     * to properly calculate the scrollTop of the panel. Because we are not\n     * actually focusing the active item, scroll must be handled manually.\n     */\n    /** The height of each autocomplete option. */\n    var AUTOCOMPLETE_OPTION_HEIGHT = 48;\n    /** The total height of the autocomplete panel. */\n    var AUTOCOMPLETE_PANEL_HEIGHT = 256;\n    /** Injection token that determines the scroll handling while the autocomplete panel is open. */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new core.InjectionToken('mat-autocomplete-scroll-strategy');\n    /** @docs-private */\n    function MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\n        return function () { return overlay.scrollStrategies.reposition(); };\n    }\n    /** @docs-private */\n    var MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\n        provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\n        deps: [overlay.Overlay],\n        useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\n    };\n    /**\n     * Provider that allows the autocomplete to register as a ControlValueAccessor.\n     * @docs-private\n     */\n    var MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\n        provide: forms.NG_VALUE_ACCESSOR,\n        useExisting: core.forwardRef(function () { return MatAutocompleteTrigger; }),\n        multi: true\n    };\n    /**\n     * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\n     * @docs-private\n     */\n    function getMatAutocompleteMissingPanelError() {\n        return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\n            'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\n            'you\\'re attempting to open it after the ngAfterContentInit hook.');\n    }\n    var MatAutocompleteTrigger = /** @class */ (function () {\n        function MatAutocompleteTrigger(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, \n        // @breaking-change 8.0.0 Make `_viewportRuler` required.\n        _viewportRuler) {\n            var _this = this;\n            this._element = _element;\n            this._overlay = _overlay;\n            this._viewContainerRef = _viewContainerRef;\n            this._zone = _zone;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._dir = _dir;\n            this._formField = _formField;\n            this._document = _document;\n            this._viewportRuler = _viewportRuler;\n            this._componentDestroyed = false;\n            this._autocompleteDisabled = false;\n            /** Whether or not the label state is being overridden. */\n            this._manuallyFloatingLabel = false;\n            /** Subscription to viewport size changes. */\n            this._viewportSubscription = rxjs.Subscription.EMPTY;\n            /**\n             * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\n             * closed autocomplete from being reopened if the user switches to another browser tab and then\n             * comes back.\n             */\n            this._canOpenOnNextFocus = true;\n            /** Stream of keyboard events that can close the panel. */\n            this._closeKeyEventStream = new rxjs.Subject();\n            /**\n             * Event handler for when the window is blurred. Needs to be an\n             * arrow function in order to preserve the context.\n             */\n            this._windowBlurHandler = function () {\n                // If the user blurred the window while the autocomplete is focused, it means that it'll be\n                // refocused when they come back. In this case we want to skip the first focus event, if the\n                // pane was closed, in order to avoid reopening it unintentionally.\n                _this._canOpenOnNextFocus =\n                    _this._document.activeElement !== _this._element.nativeElement || _this.panelOpen;\n            };\n            /** `View -> model callback called when value changes` */\n            this._onChange = function () { };\n            /** `View -> model callback called when autocomplete has been touched` */\n            this._onTouched = function () { };\n            /**\n             * Position of the autocomplete panel relative to the trigger element. A position of `auto`\n             * will render the panel underneath the trigger if there is enough space for it to fit in\n             * the viewport, otherwise the panel will be shown above it. If the position is set to\n             * `above` or `below`, the panel will always be shown above or below the trigger. no matter\n             * whether it fits completely in the viewport.\n             */\n            this.position = 'auto';\n            /**\n             * `autocomplete` attribute to be set on the input element.\n             * @docs-private\n             */\n            this.autocompleteAttribute = 'off';\n            this._overlayAttached = false;\n            /** Stream of autocomplete option selections. */\n            this.optionSelections = rxjs.defer(function () {\n                if (_this.autocomplete && _this.autocomplete.options) {\n                    return rxjs.merge.apply(void 0, tslib.__spread(_this.autocomplete.options.map(function (option) { return option.onSelectionChange; })));\n                }\n                // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\n                // Return a stream that we'll replace with the real one once everything is in place.\n                return _this._zone.onStable\n                    .asObservable()\n                    .pipe(operators.take(1), operators.switchMap(function () { return _this.optionSelections; }));\n            });\n            this._scrollStrategy = scrollStrategy;\n        }\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"autocompleteDisabled\", {\n            /**\n             * Whether the autocomplete is disabled. When disabled, the element will\n             * act as a regular input and the user won't be able to open the panel.\n             */\n            get: function () { return this._autocompleteDisabled; },\n            set: function (value) {\n                this._autocompleteDisabled = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatAutocompleteTrigger.prototype.ngAfterViewInit = function () {\n            var _this = this;\n            if (typeof window !== 'undefined') {\n                this._zone.runOutsideAngular(function () {\n                    window.addEventListener('blur', _this._windowBlurHandler);\n                });\n                if (platform._supportsShadowDom()) {\n                    var element = this._element.nativeElement;\n                    var rootNode = element.getRootNode ? element.getRootNode() : null;\n                    // We need to take the `ShadowRoot` off of `window`, because the built-in types are\n                    // incorrect. See https://github.com/Microsoft/TypeScript/issues/27929.\n                    this._isInsideShadowRoot = rootNode instanceof window.ShadowRoot;\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnChanges = function (changes) {\n            if (changes['position'] && this._positionStrategy) {\n                this._setStrategyPositions(this._positionStrategy);\n                if (this.panelOpen) {\n                    this._overlayRef.updatePosition();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype.ngOnDestroy = function () {\n            if (typeof window !== 'undefined') {\n                window.removeEventListener('blur', this._windowBlurHandler);\n            }\n            this._viewportSubscription.unsubscribe();\n            this._componentDestroyed = true;\n            this._destroyPanel();\n            this._closeKeyEventStream.complete();\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelOpen\", {\n            /** Whether or not the autocomplete panel is open. */\n            get: function () {\n                return this._overlayAttached && this.autocomplete.showPanel;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Opens the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.openPanel = function () {\n            this._attachOverlay();\n            this._floatLabel();\n        };\n        /** Closes the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype.closePanel = function () {\n            this._resetLabel();\n            if (!this._overlayAttached) {\n                return;\n            }\n            if (this.panelOpen) {\n                // Only emit if the panel was visible.\n                this.autocomplete.closed.emit();\n            }\n            this.autocomplete._isOpen = this._overlayAttached = false;\n            if (this._overlayRef && this._overlayRef.hasAttached()) {\n                this._overlayRef.detach();\n                this._closingActionsSubscription.unsubscribe();\n            }\n            // Note that in some cases this can end up being called after the component is destroyed.\n            // Add a check to ensure that we don't try to run change detection on a destroyed view.\n            if (!this._componentDestroyed) {\n                // We need to trigger change detection manually, because\n                // `fromEvent` doesn't seem to do it at the proper time.\n                // This ensures that the label is reset when the\n                // user clicks outside.\n                this._changeDetectorRef.detectChanges();\n            }\n        };\n        /**\n         * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\n         * within the viewport.\n         */\n        MatAutocompleteTrigger.prototype.updatePosition = function () {\n            if (this._overlayAttached) {\n                this._overlayRef.updatePosition();\n            }\n        };\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"panelClosingActions\", {\n            /**\n             * A stream of actions that should close the autocomplete panel, including\n             * when an option is selected, on blur, and when TAB is pressed.\n             */\n            get: function () {\n                var _this = this;\n                return rxjs.merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(operators.filter(function () { return _this._overlayAttached; })), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\n                    this._overlayRef.detachments().pipe(operators.filter(function () { return _this._overlayAttached; })) :\n                    rxjs.of()).pipe(\n                // Normalize the output so we return a consistent type.\n                operators.map(function (event) { return event instanceof core$1.MatOptionSelectionChange ? event : null; }));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatAutocompleteTrigger.prototype, \"activeOption\", {\n            /** The currently active option, coerced to MatOption type. */\n            get: function () {\n                if (this.autocomplete && this.autocomplete._keyManager) {\n                    return this.autocomplete._keyManager.activeItem;\n                }\n                return null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /** Stream of clicks outside of the autocomplete panel. */\n        MatAutocompleteTrigger.prototype._getOutsideClickStream = function () {\n            var _this = this;\n            return rxjs.merge(rxjs.fromEvent(this._document, 'click'), rxjs.fromEvent(this._document, 'touchend'))\n                .pipe(operators.filter(function (event) {\n                // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\n                // fall back to check the first element in the path of the click event.\n                var clickTarget = (_this._isInsideShadowRoot && event.composedPath ? event.composedPath()[0] :\n                    event.target);\n                var formField = _this._formField ? _this._formField._elementRef.nativeElement : null;\n                return _this._overlayAttached && clickTarget !== _this._element.nativeElement &&\n                    (!formField || !formField.contains(clickTarget)) &&\n                    (!!_this._overlayRef && !_this._overlayRef.overlayElement.contains(clickTarget));\n            }));\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.writeValue = function (value) {\n            var _this = this;\n            Promise.resolve(null).then(function () { return _this._setTriggerValue(value); });\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatAutocompleteTrigger.prototype.setDisabledState = function (isDisabled) {\n            this._element.nativeElement.disabled = isDisabled;\n        };\n        MatAutocompleteTrigger.prototype._handleKeydown = function (event) {\n            var keyCode = event.keyCode;\n            // Prevent the default action on all escape key presses. This is here primarily to bring IE\n            // in line with other browsers. By default, pressing escape on IE will cause it to revert\n            // the input value to the one that it had on focus, however it won't dispatch any events\n            // which means that the model value will be out of sync with the view.\n            if (keyCode === keycodes.ESCAPE) {\n                event.preventDefault();\n            }\n            if (this.activeOption && keyCode === keycodes.ENTER && this.panelOpen) {\n                this.activeOption._selectViaInteraction();\n                this._resetActiveItem();\n                event.preventDefault();\n            }\n            else if (this.autocomplete) {\n                var prevActiveItem = this.autocomplete._keyManager.activeItem;\n                var isArrowKey = keyCode === keycodes.UP_ARROW || keyCode === keycodes.DOWN_ARROW;\n                if (this.panelOpen || keyCode === keycodes.TAB) {\n                    this.autocomplete._keyManager.onKeydown(event);\n                }\n                else if (isArrowKey && this._canOpen()) {\n                    this.openPanel();\n                }\n                if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\n                    this._scrollToOption();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleInput = function (event) {\n            var target = event.target;\n            var value = target.value;\n            // Based on `NumberValueAccessor` from forms.\n            if (target.type === 'number') {\n                value = value == '' ? null : parseFloat(value);\n            }\n            // If the input has a placeholder, IE will fire the `input` event on page load,\n            // focus and blur, in addition to when the user actually changed the value. To\n            // filter out all of the extra events, we save the value on focus and between\n            // `input` events, and we check whether it changed.\n            // See: https://connect.microsoft.com/IE/feedback/details/885747/\n            if (this._previousValue !== value) {\n                this._previousValue = value;\n                this._onChange(value);\n                if (this._canOpen() && this._document.activeElement === event.target) {\n                    this.openPanel();\n                }\n            }\n        };\n        MatAutocompleteTrigger.prototype._handleFocus = function () {\n            if (!this._canOpenOnNextFocus) {\n                this._canOpenOnNextFocus = true;\n            }\n            else if (this._canOpen()) {\n                this._previousValue = this._element.nativeElement.value;\n                this._attachOverlay();\n                this._floatLabel(true);\n            }\n        };\n        /**\n         * In \"auto\" mode, the label will animate down as soon as focus is lost.\n         * This causes the value to jump when selecting an option with the mouse.\n         * This method manually floats the label until the panel can be closed.\n         * @param shouldAnimate Whether the label should be animated when it is floated.\n         */\n        MatAutocompleteTrigger.prototype._floatLabel = function (shouldAnimate) {\n            if (shouldAnimate === void 0) { shouldAnimate = false; }\n            if (this._formField && this._formField.floatLabel === 'auto') {\n                if (shouldAnimate) {\n                    this._formField._animateAndLockLabel();\n                }\n                else {\n                    this._formField.floatLabel = 'always';\n                }\n                this._manuallyFloatingLabel = true;\n            }\n        };\n        /** If the label has been manually elevated, return it to its normal state. */\n        MatAutocompleteTrigger.prototype._resetLabel = function () {\n            if (this._manuallyFloatingLabel) {\n                this._formField.floatLabel = 'auto';\n                this._manuallyFloatingLabel = false;\n            }\n        };\n        /**\n         * Given that we are not actually focusing active options, we must manually adjust scroll\n         * to reveal options below the fold. First, we find the offset of the option from the top\n         * of the panel. If that offset is below the fold, the new scrollTop will be the offset -\n         * the panel height + the option height, so the active option will be just visible at the\n         * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\n         * will become the offset. If that offset is visible within the panel already, the scrollTop is\n         * not adjusted.\n         */\n        MatAutocompleteTrigger.prototype._scrollToOption = function () {\n            var index = this.autocomplete._keyManager.activeItemIndex || 0;\n            var labelCount = core$1._countGroupLabelsBeforeOption(index, this.autocomplete.options, this.autocomplete.optionGroups);\n            if (index === 0 && labelCount === 1) {\n                // If we've got one group label before the option and we're at the top option,\n                // scroll the list to the top. This is better UX than scrolling the list to the\n                // top of the option, because it allows the user to read the top group's label.\n                this.autocomplete._setScrollTop(0);\n            }\n            else {\n                var newScrollPosition = core$1._getOptionScrollPosition(index + labelCount, AUTOCOMPLETE_OPTION_HEIGHT, this.autocomplete._getScrollTop(), AUTOCOMPLETE_PANEL_HEIGHT);\n                this.autocomplete._setScrollTop(newScrollPosition);\n            }\n        };\n        /**\n         * This method listens to a stream of panel closing actions and resets the\n         * stream every time the option list changes.\n         */\n        MatAutocompleteTrigger.prototype._subscribeToClosingActions = function () {\n            var _this = this;\n            var firstStable = this._zone.onStable.asObservable().pipe(operators.take(1));\n            var optionChanges = this.autocomplete.options.changes.pipe(operators.tap(function () { return _this._positionStrategy.reapplyLastPosition(); }), \n            // Defer emitting to the stream until the next tick, because changing\n            // bindings in here will cause \"changed after checked\" errors.\n            operators.delay(0));\n            // When the zone is stable initially, and when the option list changes...\n            return rxjs.merge(firstStable, optionChanges)\n                .pipe(\n            // create a new stream of panelClosingActions, replacing any previous streams\n            // that were created, and flatten it so our stream only emits closing events...\n            operators.switchMap(function () {\n                var wasOpen = _this.panelOpen;\n                _this._resetActiveItem();\n                _this.autocomplete._setVisibility();\n                if (_this.panelOpen) {\n                    _this._overlayRef.updatePosition();\n                    // If the `panelOpen` state changed, we need to make sure to emit the `opened`\n                    // event, because we may not have emitted it when the panel was attached. This\n                    // can happen if the users opens the panel and there are no options, but the\n                    // options come in slightly later or as a result of the value changing.\n                    if (wasOpen !== _this.panelOpen) {\n                        _this.autocomplete.opened.emit();\n                    }\n                }\n                return _this.panelClosingActions;\n            }), \n            // when the first closing event occurs...\n            operators.take(1))\n                // set the value, close the panel, and complete.\n                .subscribe(function (event) { return _this._setValueAndClose(event); });\n        };\n        /** Destroys the autocomplete suggestion panel. */\n        MatAutocompleteTrigger.prototype._destroyPanel = function () {\n            if (this._overlayRef) {\n                this.closePanel();\n                this._overlayRef.dispose();\n                this._overlayRef = null;\n            }\n        };\n        MatAutocompleteTrigger.prototype._setTriggerValue = function (value) {\n            var toDisplay = this.autocomplete && this.autocomplete.displayWith ?\n                this.autocomplete.displayWith(value) :\n                value;\n            // Simply falling back to an empty string if the display value is falsy does not work properly.\n            // The display value can also be the number zero and shouldn't fall back to an empty string.\n            var inputValue = toDisplay != null ? toDisplay : '';\n            // If it's used within a `MatFormField`, we should set it through the property so it can go\n            // through change detection.\n            if (this._formField) {\n                this._formField._control.value = inputValue;\n            }\n            else {\n                this._element.nativeElement.value = inputValue;\n            }\n            this._previousValue = inputValue;\n        };\n        /**\n         * This method closes the panel, and if a value is specified, also sets the associated\n         * control to that value. It will also mark the control as dirty if this interaction\n         * stemmed from the user.\n         */\n        MatAutocompleteTrigger.prototype._setValueAndClose = function (event) {\n            if (event && event.source) {\n                this._clearPreviousSelectedOption(event.source);\n                this._setTriggerValue(event.source.value);\n                this._onChange(event.source.value);\n                this._element.nativeElement.focus();\n                this.autocomplete._emitSelectEvent(event.source);\n            }\n            this.closePanel();\n        };\n        /**\n         * Clear any previous selected option and emit a selection change event for this option\n         */\n        MatAutocompleteTrigger.prototype._clearPreviousSelectedOption = function (skip) {\n            this.autocomplete.options.forEach(function (option) {\n                if (option != skip && option.selected) {\n                    option.deselect();\n                }\n            });\n        };\n        MatAutocompleteTrigger.prototype._attachOverlay = function () {\n            var _this = this;\n            if (!this.autocomplete) {\n                throw getMatAutocompleteMissingPanelError();\n            }\n            var overlayRef = this._overlayRef;\n            if (!overlayRef) {\n                this._portal = new portal.TemplatePortal(this.autocomplete.template, this._viewContainerRef);\n                overlayRef = this._overlay.create(this._getOverlayConfig());\n                this._overlayRef = overlayRef;\n                // Use the `keydownEvents` in order to take advantage of\n                // the overlay event targeting provided by the CDK overlay.\n                overlayRef.keydownEvents().subscribe(function (event) {\n                    // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\n                    // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\n                    if (event.keyCode === keycodes.ESCAPE || (event.keyCode === keycodes.UP_ARROW && event.altKey)) {\n                        _this._resetActiveItem();\n                        _this._closeKeyEventStream.next();\n                        // We need to stop propagation, otherwise the event will eventually\n                        // reach the input itself and cause the overlay to be reopened.\n                        event.stopPropagation();\n                        event.preventDefault();\n                    }\n                });\n                if (this._viewportRuler) {\n                    this._viewportSubscription = this._viewportRuler.change().subscribe(function () {\n                        if (_this.panelOpen && overlayRef) {\n                            overlayRef.updateSize({ width: _this._getPanelWidth() });\n                        }\n                    });\n                }\n            }\n            else {\n                // Update the trigger, panel width and direction, in case anything has changed.\n                this._positionStrategy.setOrigin(this._getConnectedElement());\n                overlayRef.updateSize({ width: this._getPanelWidth() });\n            }\n            if (overlayRef && !overlayRef.hasAttached()) {\n                overlayRef.attach(this._portal);\n                this._closingActionsSubscription = this._subscribeToClosingActions();\n            }\n            var wasOpen = this.panelOpen;\n            this.autocomplete._setVisibility();\n            this.autocomplete._isOpen = this._overlayAttached = true;\n            // We need to do an extra `panelOpen` check in here, because the\n            // autocomplete won't be shown if there are no options.\n            if (this.panelOpen && wasOpen !== this.panelOpen) {\n                this.autocomplete.opened.emit();\n            }\n        };\n        MatAutocompleteTrigger.prototype._getOverlayConfig = function () {\n            return new overlay.OverlayConfig({\n                positionStrategy: this._getOverlayPosition(),\n                scrollStrategy: this._scrollStrategy(),\n                width: this._getPanelWidth(),\n                direction: this._dir\n            });\n        };\n        MatAutocompleteTrigger.prototype._getOverlayPosition = function () {\n            var strategy = this._overlay.position()\n                .flexibleConnectedTo(this._getConnectedElement())\n                .withFlexibleDimensions(false)\n                .withPush(false);\n            this._setStrategyPositions(strategy);\n            this._positionStrategy = strategy;\n            return strategy;\n        };\n        /** Sets the positions on a position strategy based on the directive's input state. */\n        MatAutocompleteTrigger.prototype._setStrategyPositions = function (positionStrategy) {\n            var belowPosition = {\n                originX: 'start',\n                originY: 'bottom',\n                overlayX: 'start',\n                overlayY: 'top'\n            };\n            var abovePosition = {\n                originX: 'start',\n                originY: 'top',\n                overlayX: 'start',\n                overlayY: 'bottom',\n                // The overlay edge connected to the trigger should have squared corners, while\n                // the opposite end has rounded corners. We apply a CSS class to swap the\n                // border-radius based on the overlay position.\n                panelClass: 'mat-autocomplete-panel-above'\n            };\n            var positions;\n            if (this.position === 'above') {\n                positions = [abovePosition];\n            }\n            else if (this.position === 'below') {\n                positions = [belowPosition];\n            }\n            else {\n                positions = [belowPosition, abovePosition];\n            }\n            positionStrategy.withPositions(positions);\n        };\n        MatAutocompleteTrigger.prototype._getConnectedElement = function () {\n            if (this.connectedTo) {\n                return this.connectedTo.elementRef;\n            }\n            return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\n        };\n        MatAutocompleteTrigger.prototype._getPanelWidth = function () {\n            return this.autocomplete.panelWidth || this._getHostWidth();\n        };\n        /** Returns the width of the input element, so the panel width can match it. */\n        MatAutocompleteTrigger.prototype._getHostWidth = function () {\n            return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\n        };\n        /**\n         * Resets the active item to -1 so arrow events will activate the\n         * correct options, or to 0 if the consumer opted into it.\n         */\n        MatAutocompleteTrigger.prototype._resetActiveItem = function () {\n            this.autocomplete._keyManager.setActiveItem(this.autocomplete.autoActiveFirstOption ? 0 : -1);\n        };\n        /** Determines whether the panel can be opened. */\n        MatAutocompleteTrigger.prototype._canOpen = function () {\n            var element = this._element.nativeElement;\n            return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\n        };\n        MatAutocompleteTrigger.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"input[matAutocomplete], textarea[matAutocomplete]\",\n                        host: {\n                            'class': 'mat-autocomplete-trigger',\n                            '[attr.autocomplete]': 'autocompleteAttribute',\n                            '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\n                            '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\n                            '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\n                            '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\n                            '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\n                            '[attr.aria-haspopup]': '!autocompleteDisabled',\n                            // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\n                            // a little earlier. This avoids issues where IE delays the focusing of the input.\n                            '(focusin)': '_handleFocus()',\n                            '(blur)': '_onTouched()',\n                            '(input)': '_handleInput($event)',\n                            '(keydown)': '_handleKeydown($event)',\n                        },\n                        exportAs: 'matAutocompleteTrigger',\n                        providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\n                    },] }\n        ];\n        /** @nocollapse */\n        MatAutocompleteTrigger.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: overlay.Overlay },\n            { type: core.ViewContainerRef },\n            { type: core.NgZone },\n            { type: core.ChangeDetectorRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: formField.MatFormField, decorators: [{ type: core.Optional }, { type: core.Host }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] },\n            { type: scrolling.ViewportRuler }\n        ]; };\n        MatAutocompleteTrigger.propDecorators = {\n            autocomplete: [{ type: core.Input, args: ['matAutocomplete',] }],\n            position: [{ type: core.Input, args: ['matAutocompletePosition',] }],\n            connectedTo: [{ type: core.Input, args: ['matAutocompleteConnectedTo',] }],\n            autocompleteAttribute: [{ type: core.Input, args: ['autocomplete',] }],\n            autocompleteDisabled: [{ type: core.Input, args: ['matAutocompleteDisabled',] }]\n        };\n        return MatAutocompleteTrigger;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MatAutocompleteModule = /** @class */ (function () {\n        function MatAutocompleteModule() {\n        }\n        MatAutocompleteModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [core$1.MatOptionModule, overlay.OverlayModule, core$1.MatCommonModule, common.CommonModule],\n                        exports: [\n                            MatAutocomplete,\n                            core$1.MatOptionModule,\n                            MatAutocompleteTrigger,\n                            MatAutocompleteOrigin,\n                            core$1.MatCommonModule\n                        ],\n                        declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\n                        providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER],\n                    },] }\n        ];\n        return MatAutocompleteModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.AUTOCOMPLETE_OPTION_HEIGHT = AUTOCOMPLETE_OPTION_HEIGHT;\n    exports.AUTOCOMPLETE_PANEL_HEIGHT = AUTOCOMPLETE_PANEL_HEIGHT;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS;\n    exports.MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY = MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY;\n    exports.MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER;\n    exports.MAT_AUTOCOMPLETE_VALUE_ACCESSOR = MAT_AUTOCOMPLETE_VALUE_ACCESSOR;\n    exports.MatAutocomplete = MatAutocomplete;\n    exports.MatAutocompleteModule = MatAutocompleteModule;\n    exports.MatAutocompleteOrigin = MatAutocompleteOrigin;\n    exports.MatAutocompleteSelectedEvent = MatAutocompleteSelectedEvent;\n    exports.MatAutocompleteTrigger = MatAutocompleteTrigger;\n    exports.getMatAutocompleteMissingPanelError = getMatAutocompleteMissingPanelError;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-autocomplete.umd.js.map\n"]}