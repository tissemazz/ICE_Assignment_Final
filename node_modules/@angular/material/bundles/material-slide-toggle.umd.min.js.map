{"version":3,"sources":["src/material/material-slide-toggle.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","slideToggle","cdk","observers","core","tslib","a11y","bidi","coercion","forms","platformBrowser","animations","this","core$1","MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS","InjectionToken","providedIn","disableToggleValue","nextUniqueId","MAT_SLIDE_TOGGLE_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MatSlideToggle","multi","MatSlideToggleChange","source","checked","_super","elementRef","_focusMonitor","_changeDetectorRef","tabIndex","_ngZone","defaults","_animationMode","_dir","_this","call","_onChange","_","_onTouched","_uniqueId","_required","_checked","name","id","labelPosition","ariaLabel","ariaLabelledby","change","EventEmitter","toggleChange","dragChange","parseInt","__extends","Object","defineProperty","prototype","get","set","value","coerceBooleanProperty","enumerable","configurable","markForCheck","ngAfterContentInit","monitor","_elementRef","subscribe","focusOrigin","_inputElement","nativeElement","focus","Promise","resolve","then","ngOnDestroy","stopMonitoring","_onChangeEvent","event","stopPropagation","emit","_emitChangeEvent","_onInputClick","writeValue","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","disabled","options","focusVia","toggle","_onLabelTextChange","detectChanges","decorators","type","Component","args","selector","exportAs","host","class","[id]","[attr.tabindex]","[attr.aria-label]","[attr.aria-labelledby]","[class.mat-checked]","[class.mat-disabled]","[class.mat-slide-toggle-label-before]","[class._mat-animation-noopable]","template","providers","inputs","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","styles","ctorParameters","ElementRef","FocusMonitor","ChangeDetectorRef","String","Attribute","NgZone","undefined","Inject","Optional","ANIMATION_MODULE_TYPE","Directionality","propDecorators","_thumbEl","ViewChild","_thumbBarEl","Input","required","Output","mixinTabIndex","mixinColor","mixinDisableRipple","mixinDisabled","MatSlideToggleBase","MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR","NG_VALIDATORS","MatSlideToggleRequiredValidator","apply","arguments","Directive","CheckboxRequiredValidator","_MatSlideToggleRequiredValidatorModule","NgModule","declarations","MatSlideToggleModule","imports","MatRippleModule","MatCommonModule","ObserversModule"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/observers'), require('@angular/core'), require('@angular/material/core'), require('tslib'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('@angular/cdk/coercion'), require('@angular/forms'), require('@angular/platform-browser/animations')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/slide-toggle', ['exports', '@angular/cdk/observers', '@angular/core', '@angular/material/core', 'tslib', '@angular/cdk/a11y', '@angular/cdk/bidi', '@angular/cdk/coercion', '@angular/forms', '@angular/platform-browser/animations'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.slideToggle = {}), global.ng.cdk.observers, global.ng.core, global.ng.material.core, global.tslib, global.ng.cdk.a11y, global.ng.cdk.bidi, global.ng.cdk.coercion, global.ng.forms, global.ng.platformBrowser.animations));\n}(this, (function (exports, observers, core, core$1, tslib, a11y, bidi, coercion, forms, animations) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Injection token to be used to override the default options for `mat-slide-toggle`. */\n    var MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = new core.InjectionToken('mat-slide-toggle-default-options', {\n        providedIn: 'root',\n        factory: function () { return ({ disableToggleValue: false }); }\n    });\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Increasing integer for generating unique ids for slide-toggle components.\n    var nextUniqueId = 0;\n    /** @docs-private */\n    var MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = {\n        provide: forms.NG_VALUE_ACCESSOR,\n        useExisting: core.forwardRef(function () { return MatSlideToggle; }),\n        multi: true\n    };\n    /** Change event object emitted by a MatSlideToggle. */\n    var MatSlideToggleChange = /** @class */ (function () {\n        function MatSlideToggleChange(\n        /** The source MatSlideToggle of the event. */\n        source, \n        /** The new `checked` value of the MatSlideToggle. */\n        checked) {\n            this.source = source;\n            this.checked = checked;\n        }\n        return MatSlideToggleChange;\n    }());\n    // Boilerplate for applying mixins to MatSlideToggle.\n    /** @docs-private */\n    var MatSlideToggleBase = /** @class */ (function () {\n        function MatSlideToggleBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatSlideToggleBase;\n    }());\n    var _MatSlideToggleMixinBase = core$1.mixinTabIndex(core$1.mixinColor(core$1.mixinDisableRipple(core$1.mixinDisabled(MatSlideToggleBase)), 'accent'));\n    /** Represents a slidable \"switch\" toggle that can be moved between on and off. */\n    var MatSlideToggle = /** @class */ (function (_super) {\n        tslib.__extends(MatSlideToggle, _super);\n        function MatSlideToggle(elementRef, _focusMonitor, _changeDetectorRef, tabIndex, \n        /**\n         * @deprecated `_ngZone` and `_dir` parameters to be removed.\n         * @breaking-change 10.0.0\n         */\n        _ngZone, defaults, _animationMode, _dir) {\n            var _this = _super.call(this, elementRef) || this;\n            _this._focusMonitor = _focusMonitor;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this.defaults = defaults;\n            _this._animationMode = _animationMode;\n            _this._onChange = function (_) { };\n            _this._onTouched = function () { };\n            _this._uniqueId = \"mat-slide-toggle-\" + ++nextUniqueId;\n            _this._required = false;\n            _this._checked = false;\n            /** Name value will be applied to the input element if present. */\n            _this.name = null;\n            /** A unique id for the slide-toggle input. If none is supplied, it will be auto-generated. */\n            _this.id = _this._uniqueId;\n            /** Whether the label should appear after or before the slide-toggle. Defaults to 'after'. */\n            _this.labelPosition = 'after';\n            /** Used to set the aria-label attribute on the underlying input element. */\n            _this.ariaLabel = null;\n            /** Used to set the aria-labelledby attribute on the underlying input element. */\n            _this.ariaLabelledby = null;\n            /** An event will be dispatched each time the slide-toggle changes its value. */\n            _this.change = new core.EventEmitter();\n            /**\n             * An event will be dispatched each time the slide-toggle input is toggled.\n             * This event is always emitted when the user toggles the slide toggle, but this does not mean\n             * the slide toggle's value has changed.\n             */\n            _this.toggleChange = new core.EventEmitter();\n            /**\n             * An event will be dispatched each time the slide-toggle is dragged.\n             * This event is always emitted when the user drags the slide toggle to make a change greater\n             * than 50%. It does not mean the slide toggle's value is changed. The event is not emitted when\n             * the user toggles the slide toggle to change its value.\n             * @deprecated No longer being used. To be removed.\n             * @breaking-change 10.0.0\n             */\n            _this.dragChange = new core.EventEmitter();\n            _this.tabIndex = parseInt(tabIndex) || 0;\n            return _this;\n        }\n        Object.defineProperty(MatSlideToggle.prototype, \"required\", {\n            /** Whether the slide-toggle is required. */\n            get: function () { return this._required; },\n            set: function (value) { this._required = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatSlideToggle.prototype, \"checked\", {\n            /** Whether the slide-toggle element is checked or not. */\n            get: function () { return this._checked; },\n            set: function (value) {\n                this._checked = coercion.coerceBooleanProperty(value);\n                this._changeDetectorRef.markForCheck();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatSlideToggle.prototype, \"inputId\", {\n            /** Returns the unique id for the visual hidden input. */\n            get: function () { return (this.id || this._uniqueId) + \"-input\"; },\n            enumerable: true,\n            configurable: true\n        });\n        MatSlideToggle.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._focusMonitor\n                .monitor(this._elementRef, true)\n                .subscribe(function (focusOrigin) {\n                // Only forward focus manually when it was received programmatically or through the\n                // keyboard. We should not do this for mouse/touch focus for two reasons:\n                // 1. It can prevent clicks from landing in Chrome (see #18269).\n                // 2. They're already handled by the wrapping `label` element.\n                if (focusOrigin === 'keyboard' || focusOrigin === 'program') {\n                    _this._inputElement.nativeElement.focus();\n                }\n                else if (!focusOrigin) {\n                    // When a focused element becomes disabled, the browser *immediately* fires a blur event.\n                    // Angular does not expect events to be raised during change detection, so any state\n                    // change (such as a form control's 'ng-touched') will cause a changed-after-checked\n                    // error. See https://github.com/angular/angular/issues/17793. To work around this,\n                    // we defer telling the form control it has been touched until the next tick.\n                    Promise.resolve().then(function () { return _this._onTouched(); });\n                }\n            });\n        };\n        MatSlideToggle.prototype.ngOnDestroy = function () {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        };\n        /** Method being called whenever the underlying input emits a change event. */\n        MatSlideToggle.prototype._onChangeEvent = function (event) {\n            // We always have to stop propagation on the change event.\n            // Otherwise the change event, from the input element, will bubble up and\n            // emit its event object to the component's `change` output.\n            event.stopPropagation();\n            this.toggleChange.emit();\n            // When the slide toggle's config disables toggle change event by setting\n            // `disableToggleValue: true`, the slide toggle's value does not change, and the\n            // checked state of the underlying input needs to be changed back.\n            if (this.defaults.disableToggleValue) {\n                this._inputElement.nativeElement.checked = this.checked;\n                return;\n            }\n            // Sync the value from the underlying input element with the component instance.\n            this.checked = this._inputElement.nativeElement.checked;\n            // Emit our custom change event only if the underlying input emitted one. This ensures that\n            // there is no change event, when the checked state changes programmatically.\n            this._emitChangeEvent();\n        };\n        /** Method being called whenever the slide-toggle has been clicked. */\n        MatSlideToggle.prototype._onInputClick = function (event) {\n            // We have to stop propagation for click events on the visual hidden input element.\n            // By default, when a user clicks on a label element, a generated click event will be\n            // dispatched on the associated input element. Since we are using a label element as our\n            // root container, the click event on the `slide-toggle` will be executed twice.\n            // The real click event will bubble up, and the generated click event also tries to bubble up.\n            // This will lead to multiple click events.\n            // Preventing bubbling for the second event will solve that issue.\n            event.stopPropagation();\n        };\n        /** Implemented as part of ControlValueAccessor. */\n        MatSlideToggle.prototype.writeValue = function (value) {\n            this.checked = !!value;\n        };\n        /** Implemented as part of ControlValueAccessor. */\n        MatSlideToggle.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        /** Implemented as part of ControlValueAccessor. */\n        MatSlideToggle.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        /** Implemented as a part of ControlValueAccessor. */\n        MatSlideToggle.prototype.setDisabledState = function (isDisabled) {\n            this.disabled = isDisabled;\n            this._changeDetectorRef.markForCheck();\n        };\n        /** Focuses the slide-toggle. */\n        MatSlideToggle.prototype.focus = function (options) {\n            this._focusMonitor.focusVia(this._inputElement, 'keyboard', options);\n        };\n        /** Toggles the checked state of the slide-toggle. */\n        MatSlideToggle.prototype.toggle = function () {\n            this.checked = !this.checked;\n            this._onChange(this.checked);\n        };\n        /**\n         * Emits a change event on the `change` output. Also notifies the FormControl about the change.\n         */\n        MatSlideToggle.prototype._emitChangeEvent = function () {\n            this._onChange(this.checked);\n            this.change.emit(new MatSlideToggleChange(this, this.checked));\n        };\n        /** Method being called whenever the label text changes. */\n        MatSlideToggle.prototype._onLabelTextChange = function () {\n            // Since the event of the `cdkObserveContent` directive runs outside of the zone, the\n            // slide-toggle component will be only marked for check, but no actual change detection runs\n            // automatically. Instead of going back into the zone in order to trigger a change detection\n            // which causes *all* components to be checked (if explicitly marked or not using OnPush),\n            // we only trigger an explicit change detection for the slide-toggle view and its children.\n            this._changeDetectorRef.detectChanges();\n        };\n        MatSlideToggle.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-slide-toggle',\n                        exportAs: 'matSlideToggle',\n                        host: {\n                            'class': 'mat-slide-toggle',\n                            '[id]': 'id',\n                            // Needs to be `-1` so it can still receive programmatic focus.\n                            '[attr.tabindex]': 'disabled ? null : -1',\n                            '[attr.aria-label]': 'null',\n                            '[attr.aria-labelledby]': 'null',\n                            '[class.mat-checked]': 'checked',\n                            '[class.mat-disabled]': 'disabled',\n                            '[class.mat-slide-toggle-label-before]': 'labelPosition == \"before\"',\n                            '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"',\n                        },\n                        template: \"<label [attr.for]=\\\"inputId\\\" class=\\\"mat-slide-toggle-label\\\" #label>\\n  <div #toggleBar class=\\\"mat-slide-toggle-bar\\\"\\n       [class.mat-slide-toggle-bar-no-side-margin]=\\\"!labelContent.textContent || !labelContent.textContent.trim()\\\">\\n\\n    <input #input class=\\\"mat-slide-toggle-input cdk-visually-hidden\\\" type=\\\"checkbox\\\"\\n           role=\\\"switch\\\"\\n           [id]=\\\"inputId\\\"\\n           [required]=\\\"required\\\"\\n           [tabIndex]=\\\"tabIndex\\\"\\n           [checked]=\\\"checked\\\"\\n           [disabled]=\\\"disabled\\\"\\n           [attr.name]=\\\"name\\\"\\n           [attr.aria-checked]=\\\"checked.toString()\\\"\\n           [attr.aria-label]=\\\"ariaLabel\\\"\\n           [attr.aria-labelledby]=\\\"ariaLabelledby\\\"\\n           (change)=\\\"_onChangeEvent($event)\\\"\\n           (click)=\\\"_onInputClick($event)\\\">\\n\\n    <div class=\\\"mat-slide-toggle-thumb-container\\\" #thumbContainer>\\n      <div class=\\\"mat-slide-toggle-thumb\\\"></div>\\n      <div class=\\\"mat-slide-toggle-ripple mat-focus-indicator\\\" mat-ripple\\n           [matRippleTrigger]=\\\"label\\\"\\n           [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n           [matRippleCentered]=\\\"true\\\"\\n           [matRippleRadius]=\\\"20\\\"\\n           [matRippleAnimation]=\\\"{enterDuration: 150}\\\">\\n\\n        <div class=\\\"mat-ripple-element mat-slide-toggle-persistent-ripple\\\"></div>\\n      </div>\\n    </div>\\n\\n  </div>\\n\\n  <span class=\\\"mat-slide-toggle-content\\\" #labelContent (cdkObserveContent)=\\\"_onLabelTextChange()\\\">\\n    <!-- Add an invisible span so JAWS can read the label -->\\n    <span style=\\\"display:none\\\">&nbsp;</span>\\n    <ng-content></ng-content>\\n  </span>\\n</label>\\n\",\n                        providers: [MAT_SLIDE_TOGGLE_VALUE_ACCESSOR],\n                        inputs: ['disabled', 'disableRipple', 'color', 'tabIndex'],\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        styles: [\".mat-slide-toggle{display:inline-block;height:24px;max-width:100%;line-height:24px;white-space:nowrap;outline:none;-webkit-tap-highlight-color:transparent}.mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(16px, 0, 0)}[dir=rtl] .mat-slide-toggle.mat-checked .mat-slide-toggle-thumb-container{transform:translate3d(-16px, 0, 0)}.mat-slide-toggle.mat-disabled{opacity:.38}.mat-slide-toggle.mat-disabled .mat-slide-toggle-label,.mat-slide-toggle.mat-disabled .mat-slide-toggle-thumb-container{cursor:default}.mat-slide-toggle-label{display:flex;flex:1;flex-direction:row;align-items:center;height:inherit;cursor:pointer}.mat-slide-toggle-content{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-slide-toggle-label-before .mat-slide-toggle-label{order:1}.mat-slide-toggle-label-before .mat-slide-toggle-bar{order:2}[dir=rtl] .mat-slide-toggle-label-before .mat-slide-toggle-bar,.mat-slide-toggle-bar{margin-right:8px;margin-left:0}[dir=rtl] .mat-slide-toggle-bar,.mat-slide-toggle-label-before .mat-slide-toggle-bar{margin-left:8px;margin-right:0}.mat-slide-toggle-bar-no-side-margin{margin-left:0;margin-right:0}.mat-slide-toggle-thumb-container{position:absolute;z-index:1;width:20px;height:20px;top:-3px;left:0;transform:translate3d(0, 0, 0);transition:all 80ms linear;transition-property:transform}._mat-animation-noopable .mat-slide-toggle-thumb-container{transition:none}[dir=rtl] .mat-slide-toggle-thumb-container{left:auto;right:0}.mat-slide-toggle-thumb{height:20px;width:20px;border-radius:50%}.mat-slide-toggle-bar{position:relative;width:36px;height:14px;flex-shrink:0;border-radius:8px}.mat-slide-toggle-input{bottom:0;left:10px}[dir=rtl] .mat-slide-toggle-input{left:auto;right:10px}.mat-slide-toggle-bar,.mat-slide-toggle-thumb{transition:all 80ms linear;transition-property:background-color;transition-delay:50ms}._mat-animation-noopable .mat-slide-toggle-bar,._mat-animation-noopable .mat-slide-toggle-thumb{transition:none}.mat-slide-toggle .mat-slide-toggle-ripple{position:absolute;top:calc(50% - 20px);left:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.mat-slide-toggle .mat-slide-toggle-ripple .mat-ripple-element:not(.mat-slide-toggle-persistent-ripple){opacity:.12}.mat-slide-toggle-persistent-ripple{width:100%;height:100%;transform:none}.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:.04}.mat-slide-toggle:not(.mat-disabled).cdk-keyboard-focused .mat-slide-toggle-persistent-ripple{opacity:.12}.mat-slide-toggle-persistent-ripple,.mat-slide-toggle.mat-disabled .mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{opacity:0}@media(hover: none){.mat-slide-toggle-bar:hover .mat-slide-toggle-persistent-ripple{display:none}}.cdk-high-contrast-active .mat-slide-toggle-thumb,.cdk-high-contrast-active .mat-slide-toggle-bar{border:1px solid}.cdk-high-contrast-active .mat-slide-toggle.cdk-keyboard-focused .mat-slide-toggle-bar{outline:2px dotted;outline-offset:5px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatSlideToggle.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: a11y.FocusMonitor },\n            { type: core.ChangeDetectorRef },\n            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },\n            { type: core.NgZone },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS,] }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] }\n        ]; };\n        MatSlideToggle.propDecorators = {\n            _thumbEl: [{ type: core.ViewChild, args: ['thumbContainer',] }],\n            _thumbBarEl: [{ type: core.ViewChild, args: ['toggleBar',] }],\n            name: [{ type: core.Input }],\n            id: [{ type: core.Input }],\n            labelPosition: [{ type: core.Input }],\n            ariaLabel: [{ type: core.Input, args: ['aria-label',] }],\n            ariaLabelledby: [{ type: core.Input, args: ['aria-labelledby',] }],\n            required: [{ type: core.Input }],\n            checked: [{ type: core.Input }],\n            change: [{ type: core.Output }],\n            toggleChange: [{ type: core.Output }],\n            dragChange: [{ type: core.Output }],\n            _inputElement: [{ type: core.ViewChild, args: ['input',] }]\n        };\n        return MatSlideToggle;\n    }(_MatSlideToggleMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = {\n        provide: forms.NG_VALIDATORS,\n        useExisting: core.forwardRef(function () { return MatSlideToggleRequiredValidator; }),\n        multi: true\n    };\n    /**\n     * Validator for Material slide-toggle components with the required attribute in a\n     * template-driven form. The default validator for required form controls asserts\n     * that the control value is not undefined but that is not appropriate for a slide-toggle\n     * where the value is always defined.\n     *\n     * Required slide-toggle form controls are valid when checked.\n     */\n    var MatSlideToggleRequiredValidator = /** @class */ (function (_super) {\n        tslib.__extends(MatSlideToggleRequiredValidator, _super);\n        function MatSlideToggleRequiredValidator() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        MatSlideToggleRequiredValidator.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"mat-slide-toggle[required][formControlName],\\n             mat-slide-toggle[required][formControl], mat-slide-toggle[required][ngModel]\",\n                        providers: [MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR],\n                    },] }\n        ];\n        return MatSlideToggleRequiredValidator;\n    }(forms.CheckboxRequiredValidator));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** This module is used by both original and MDC-based slide-toggle implementations. */\n    var _MatSlideToggleRequiredValidatorModule = /** @class */ (function () {\n        function _MatSlideToggleRequiredValidatorModule() {\n        }\n        _MatSlideToggleRequiredValidatorModule.decorators = [\n            { type: core.NgModule, args: [{\n                        exports: [MatSlideToggleRequiredValidator],\n                        declarations: [MatSlideToggleRequiredValidator],\n                    },] }\n        ];\n        return _MatSlideToggleRequiredValidatorModule;\n    }());\n    var MatSlideToggleModule = /** @class */ (function () {\n        function MatSlideToggleModule() {\n        }\n        MatSlideToggleModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [\n                            _MatSlideToggleRequiredValidatorModule,\n                            core$1.MatRippleModule,\n                            core$1.MatCommonModule,\n                            observers.ObserversModule,\n                        ],\n                        exports: [\n                            _MatSlideToggleRequiredValidatorModule,\n                            MatSlideToggle,\n                            core$1.MatCommonModule\n                        ],\n                        declarations: [MatSlideToggle],\n                    },] }\n        ];\n        return MatSlideToggleModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS = MAT_SLIDE_TOGGLE_DEFAULT_OPTIONS;\n    exports.MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR = MAT_SLIDE_TOGGLE_REQUIRED_VALIDATOR;\n    exports.MAT_SLIDE_TOGGLE_VALUE_ACCESSOR = MAT_SLIDE_TOGGLE_VALUE_ACCESSOR;\n    exports.MatSlideToggle = MatSlideToggle;\n    exports.MatSlideToggleChange = MatSlideToggleChange;\n    exports.MatSlideToggleModule = MatSlideToggleModule;\n    exports.MatSlideToggleRequiredValidator = MatSlideToggleRequiredValidator;\n    exports._MatSlideToggleRequiredValidatorModule = _MatSlideToggleRequiredValidatorModule;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-slide-toggle.umd.js.map\n"]}