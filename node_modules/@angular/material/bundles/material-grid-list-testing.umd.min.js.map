{"version":3,"sources":["src/material/material-grid-list-testing.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","gridList","testing","tslib","cdk","this","MatGridTileHarness","_super","_this","apply","arguments","_header","locatorForOptional","_footer","_avatar","__extends","with","options","HarnessPredicate","addOption","headerText","harness","pattern","stringMatches","getHeaderText","footerText","getFooterText","prototype","getRowspan","__awaiter","_a","__generator","_b","label","Number","host","sent","getAttribute","getColspan","hasHeader","hasFooter","hasAvatar","headerEl","text","hostSelector","ComponentHarness","MatGridListHarness","_tileCoordinator","ÉµTileCoordinator","getTiles","filters","locatorForAll","getColumns","getTileAtPosition","row","column","tileHarnesses","columns","tileSpans","tiles","i","position","_c","rowspan","colspan","_d","Promise","all","__read","map","t","update","positions","length","col","Error","Object","defineProperty","value"],"mappings":"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","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('@angular/cdk/testing'), require('@angular/material/grid-list')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/grid-list/testing', ['exports', 'tslib', '@angular/cdk/testing', '@angular/material/grid-list'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.gridList = global.ng.material.gridList || {}, global.ng.material.gridList.testing = {}), global.tslib, global.ng.cdk.testing, global.ng.material.gridList));\n}(this, (function (exports, tslib, testing, gridList) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Harness for interacting with a standard `MatGridTitle` in tests. */\n    var MatGridTileHarness = /** @class */ (function (_super) {\n        tslib.__extends(MatGridTileHarness, _super);\n        function MatGridTileHarness() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            _this._header = _this.locatorForOptional('.mat-grid-tile-header');\n            _this._footer = _this.locatorForOptional('.mat-grid-tile-footer');\n            _this._avatar = _this.locatorForOptional('.mat-grid-avatar');\n            return _this;\n        }\n        /**\n         * Gets a `HarnessPredicate` that can be used to search for a `MatGridTileHarness`\n         * that meets certain criteria.\n         * @param options Options for filtering which dialog instances are considered a match.\n         * @return a `HarnessPredicate` configured with the given options.\n         */\n        MatGridTileHarness.with = function (options) {\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatGridTileHarness, options)\n                .addOption('headerText', options.headerText, function (harness, pattern) { return testing.HarnessPredicate.stringMatches(harness.getHeaderText(), pattern); })\n                .addOption('footerText', options.footerText, function (harness, pattern) { return testing.HarnessPredicate.stringMatches(harness.getFooterText(), pattern); });\n        };\n        /** Gets the amount of rows that the grid-tile takes up. */\n        MatGridTileHarness.prototype.getRowspan = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var _a;\n                return tslib.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = Number;\n                            return [4 /*yield*/, this.host()];\n                        case 1: return [4 /*yield*/, (_b.sent()).getAttribute('rowspan')];\n                        case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        /** Gets the amount of columns that the grid-tile takes up. */\n        MatGridTileHarness.prototype.getColspan = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var _a;\n                return tslib.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = Number;\n                            return [4 /*yield*/, this.host()];\n                        case 1: return [4 /*yield*/, (_b.sent()).getAttribute('colspan')];\n                        case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        /** Whether the grid-tile has a header. */\n        MatGridTileHarness.prototype.hasHeader = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._header()];\n                        case 1: return [2 /*return*/, (_a.sent()) !== null];\n                    }\n                });\n            });\n        };\n        /** Whether the grid-tile has a footer. */\n        MatGridTileHarness.prototype.hasFooter = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._footer()];\n                        case 1: return [2 /*return*/, (_a.sent()) !== null];\n                    }\n                });\n            });\n        };\n        /** Whether the grid-tile has an avatar. */\n        MatGridTileHarness.prototype.hasAvatar = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._avatar()];\n                        case 1: return [2 /*return*/, (_a.sent()) !== null];\n                    }\n                });\n            });\n        };\n        /** Gets the text of the header if present. */\n        MatGridTileHarness.prototype.getHeaderText = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var headerEl;\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._header()];\n                        case 1:\n                            headerEl = _a.sent();\n                            return [2 /*return*/, headerEl ? headerEl.text() : null];\n                    }\n                });\n            });\n        };\n        /** Gets the text of the footer if present. */\n        MatGridTileHarness.prototype.getFooterText = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var headerEl;\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this._footer()];\n                        case 1:\n                            headerEl = _a.sent();\n                            return [2 /*return*/, headerEl ? headerEl.text() : null];\n                    }\n                });\n            });\n        };\n        /** The selector for the host element of a `MatGridTile` instance. */\n        MatGridTileHarness.hostSelector = '.mat-grid-tile';\n        return MatGridTileHarness;\n    }(testing.ComponentHarness));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Harness for interacting with a standard `MatGridList` in tests. */\n    var MatGridListHarness = /** @class */ (function (_super) {\n        tslib.__extends(MatGridListHarness, _super);\n        function MatGridListHarness() {\n            var _this = _super !== null && _super.apply(this, arguments) || this;\n            /**\n             * Tile coordinator that is used by the \"MatGridList\" for computing\n             * positions of tiles. We leverage the coordinator to provide an API\n             * for retrieving tiles based on visual tile positions.\n             */\n            _this._tileCoordinator = new gridList.ÉµTileCoordinator();\n            return _this;\n        }\n        /**\n         * Gets a `HarnessPredicate` that can be used to search for a `MatGridListHarness`\n         * that meets certain criteria.\n         * @param options Options for filtering which dialog instances are considered a match.\n         * @return a `HarnessPredicate` configured with the given options.\n         */\n        MatGridListHarness.with = function (options) {\n            if (options === void 0) { options = {}; }\n            return new testing.HarnessPredicate(MatGridListHarness, options);\n        };\n        /** Gets all tiles of the grid-list. */\n        MatGridListHarness.prototype.getTiles = function (filters) {\n            if (filters === void 0) { filters = {}; }\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                return tslib.__generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0: return [4 /*yield*/, this.locatorForAll(MatGridTileHarness.with(filters))()];\n                        case 1: return [2 /*return*/, _a.sent()];\n                    }\n                });\n            });\n        };\n        /** Gets the amount of columns of the grid-list. */\n        MatGridListHarness.prototype.getColumns = function () {\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var _a;\n                return tslib.__generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            _a = Number;\n                            return [4 /*yield*/, this.host()];\n                        case 1: return [4 /*yield*/, (_b.sent()).getAttribute('cols')];\n                        case 2: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n                    }\n                });\n            });\n        };\n        /**\n         * Gets a tile of the grid-list that is located at the given location.\n         * @param row Zero-based row index.\n         * @param column Zero-based column index.\n         */\n        MatGridListHarness.prototype.getTileAtPosition = function (_a) {\n            var row = _a.row, column = _a.column;\n            return tslib.__awaiter(this, void 0, void 0, function () {\n                var _b, tileHarnesses, columns, tileSpans, tiles, i, position, _c, rowspan, colspan;\n                return tslib.__generator(this, function (_d) {\n                    switch (_d.label) {\n                        case 0: return [4 /*yield*/, Promise.all([this.getTiles(), this.getColumns()])];\n                        case 1:\n                            _b = tslib.__read.apply(void 0, [_d.sent(), 2]), tileHarnesses = _b[0], columns = _b[1];\n                            tileSpans = tileHarnesses.map(function (t) { return Promise.all([t.getColspan(), t.getRowspan()]); });\n                            return [4 /*yield*/, Promise.all(tileSpans)];\n                        case 2:\n                            tiles = (_d.sent()).map(function (_a) {\n                                var _b = tslib.__read(_a, 2), colspan = _b[0], rowspan = _b[1];\n                                return ({ colspan: colspan, rowspan: rowspan });\n                            });\n                            // Update the tile coordinator to reflect the current column amount and\n                            // rendered tiles. We update upon every call of this method since we do not\n                            // know if tiles have been added, removed or updated (in terms of rowspan/colspan).\n                            this._tileCoordinator.update(columns, tiles);\n                            // The tile coordinator respects the colspan and rowspan for calculating the positions\n                            // of tiles, but it does not create multiple position entries if a tile spans over multiple\n                            // columns or rows. We want to provide an API where developers can retrieve a tile based on\n                            // any position that lies within the visual tile boundaries. For example: If a tile spans\n                            // over two columns, then the same tile should be returned for either column indices.\n                            for (i = 0; i < this._tileCoordinator.positions.length; i++) {\n                                position = this._tileCoordinator.positions[i];\n                                _c = tiles[i], rowspan = _c.rowspan, colspan = _c.colspan;\n                                // Return the tile harness if the given position visually resolves to the tile.\n                                if (column >= position.col && column <= position.col + colspan - 1 && row >= position.row &&\n                                    row <= position.row + rowspan - 1) {\n                                    return [2 /*return*/, tileHarnesses[i]];\n                                }\n                            }\n                            throw Error('Could not find tile at given position.');\n                    }\n                });\n            });\n        };\n        /** The selector for the host element of a `MatGridList` instance. */\n        MatGridListHarness.hostSelector = '.mat-grid-list';\n        return MatGridListHarness;\n    }(testing.ComponentHarness));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    exports.MatGridListHarness = MatGridListHarness;\n    exports.MatGridTileHarness = MatGridTileHarness;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-grid-list-testing.umd.js.map\n"]}