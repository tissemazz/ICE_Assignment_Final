{"version":3,"sources":["src/material/material-chips.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ng","material","chips","cdk","keycodes","core","tslib","common","coercion","platform","rxjs","operators","platformBrowser","animations","a11y","bidi","collections","forms","formField","this","core$1","MatChipSelectionChange","source","selected","isUserInput","_MatChipMixinBase","mixinTabIndex","mixinColor","mixinDisableRipple","mixinDisabled","MatChipBase","_elementRef","MatChipAvatar","decorators","type","Directive","args","selector","host","class","MatChipTrailingIcon","MatChip","_super","_ngZone","globalRippleOptions","animationMode","_changeDetectorRef","tabIndex","_document","_this","call","_hasFocus","chipListSelectable","_chipListMultiple","_selected","_selectable","_removable","_onFocus","Subject","_onBlur","selectionChange","EventEmitter","destroyed","removed","_addHostClassName","_chipRippleTarget","document","createElement","classList","add","nativeElement","appendChild","_chipRipple","RippleRenderer","setupTriggerEvents","rippleConfig","_animationsDisabled","parseInt","__extends","Object","defineProperty","prototype","get","disabled","disableRipple","enumerable","configurable","set","value","coercedValue","coerceBooleanProperty","_dispatchSelectionChange","undefined","_value","textContent","selectable","toString","element","hasAttribute","tagName","toLowerCase","ngOnDestroy","emit","chip","_removeTriggerEvents","select","_markForCheck","deselect","selectViaInteraction","toggleSelected","focus","next","remove","removable","_handleClick","event","preventDefault","stopPropagation","_handleKeydown","keyCode","DELETE","BACKSPACE","SPACE","_blur","onStable","asObservable","pipe","take","subscribe","run","markForCheck","inputs","exportAs","[attr.tabindex]","role","[class.mat-chip-selected]","[class.mat-chip-with-avatar]","[class.mat-chip-with-trailing-icon]","[class.mat-chip-disabled]","[class._mat-animation-noopable]","[attr.disabled]","[attr.aria-disabled]","[attr.aria-selected]","(click)","(keydown)","(focus)","(blur)","ctorParameters","ElementRef","NgZone","Platform","Optional","Inject","MAT_RIPPLE_GLOBAL_OPTIONS","String","ANIMATION_MODULE_TYPE","ChangeDetectorRef","Attribute","DOCUMENT","propDecorators","avatar","ContentChild","trailingIcon","removeIcon","forwardRef","MatChipRemove","Input","Output","_parentChip","elementRef","nodeName","setAttribute","parentChip","MAT_CHIPS_DEFAULT_OPTIONS","InjectionToken","_MatChipListMixinBase","mixinErrorState","MatChipListBase","_defaultErrorStateMatcher","_parentForm","_parentFormGroup","ngControl","nextUniqueId","MatChipListChange","MatChipList","_dir","controlType","_lastDestroyedChipIndex","_destroyed","_uid","_tabIndex","_userTabIndex","_onTouched","_onChange","_multiple","_compareWith","o1","o2","_required","_disabled","ariaOrientation","change","valueChange","valueAccessor","multiple","_selectionModel","empty","_syncChipsState","fn","_initializeSelection","writeValue","_chipInput","id","stateChanges","placeholder","_placeholder","focused","_hasFocusedChip","length","forEach","merge","apply","__spread","map","ngAfterContentInit","_keyManager","FocusKeyManager","withWrap","withVerticalOrientation","withHorizontalOrientation","takeUntil","dir","tabOut","_allowFocusEscape","changes","startWith","Promise","resolve","then","_resetChips","_updateTabIndex","_updateFocusForDestroyedChips","ngOnInit","SelectionModel","ngDoCheck","updateErrorState","complete","_dropSubscriptions","registerInput","inputElement","setDescribedByIds","ids","_ariaDescribedby","join","_setSelectionByValue","registerOnChange","registerOnTouched","setDisabledState","isDisabled","onContainerClick","_originatesFromChip","options","setFirstItemActive","_focusInput","_keydown","target","_isInputEmpty","setLastItemActive","contains","HOME","END","onKeydown","newChipIndex","Math","min","setActiveItem","_isValidIndex","index","_clearSelection","Array","isArray","currentValue","_selectValue","_sortValues","correspondingChip","find","skip","clear","_propagateChanges","fallbackValue","valueToEmit","setTimeout","_markAsTouched","_listenToChipsFocus","_listenToChipsSelection","_listenToChipsRemoved","_chipFocusSubscription","unsubscribe","_chipBlurSubscription","_chipSelectionSubscription","_chipRemoveSubscription","chipSelectionChanges","isSelected","chipFocusChanges","chipIndex","toArray","indexOf","updateActiveItem","chipBlurChanges","chipRemoveChanges","currentElement","parentElement","some","Component","template","[attr.aria-describedby]","[attr.aria-required]","[attr.aria-invalid]","[attr.aria-multiselectable]","[attr.role]","[class.mat-chip-list-disabled]","[class.mat-chip-list-invalid]","[class.mat-chip-list-required]","[attr.aria-orientation]","[id]","providers","provide","MatFormFieldControl","useExisting","encapsulation","ViewEncapsulation","None","changeDetection","ChangeDetectionStrategy","OnPush","styles","Directionality","NgForm","FormGroupDirective","ErrorStateMatcher","NgControl","Self","errorStateMatcher","compareWith","required","ContentChildren","descendants","nextUniqueId$1","MatChipInput","_defaultOptions","_addOnBlur","separatorKeyCodes","chipEnd","_inputElement","_chipList","ngOnChanges","TAB","hasModifierKey","_emitChipEnd","addOnBlur","_focus","_isSeparatorKey","input","_onInput","separators","has","(input)","[attr.placeholder]","chipList","CHIP_DECLARATIONS","Éµ0","ENTER","MatChipsModule","NgModule","declarations","useValue"],"mappings":"CAAC,SAAUA,EAAQC,GACI,iBAAZC,SAA0C,oBAAXC,OAAyBF,EAAQC,QAASE,QAAQ,yBAA0BA,QAAQ,iBAAkBA,QAAQ,0BAA2BA,QAAQ,SAAUA,QAAQ,mBAAoBA,QAAQ,yBAA0BA,QAAQ,yBAA0BA,QAAQ,QAASA,QAAQ,kBAAmBA,QAAQ,wCAAyCA,QAAQ,qBAAsBA,QAAQ,qBAAsBA,QAAQ,4BAA6BA,QAAQ,kBAAmBA,QAAQ,iCAChf,mBAAXC,QAAyBA,OAAOC,IAAMD,OAAO,0BAA2B,CAAC,UAAW,wBAAyB,gBAAiB,yBAA0B,QAAS,kBAAmB,wBAAyB,wBAAyB,OAAQ,iBAAkB,uCAAwC,oBAAqB,oBAAqB,2BAA4B,iBAAkB,gCAAiCJ,GAC9YA,IAAzBD,EAASA,GAAUO,MAAsBC,GAAKR,EAAOQ,IAAM,GAAIR,EAAOQ,GAAGC,SAAWT,EAAOQ,GAAGC,UAAY,GAAIT,EAAOQ,GAAGC,SAASC,MAAQ,IAAKV,EAAOQ,GAAGG,IAAIC,SAAUZ,EAAOQ,GAAGK,KAAMb,EAAOQ,GAAGC,SAASI,KAAMb,EAAOc,MAAOd,EAAOQ,GAAGO,OAAQf,EAAOQ,GAAGG,IAAIK,SAAUhB,EAAOQ,GAAGG,IAAIM,SAAUjB,EAAOkB,KAAMlB,EAAOkB,KAAKC,UAAWnB,EAAOQ,GAAGY,gBAAgBC,WAAYrB,EAAOQ,GAAGG,IAAIW,KAAMtB,EAAOQ,GAAGG,IAAIY,KAAMvB,EAAOQ,GAAGG,IAAIa,YAAaxB,EAAOQ,GAAGiB,MAAOzB,EAAOQ,GAAGC,SAASiB,WAHrd,CAIEC,MAAM,SAAWzB,EAASU,EAAUC,EAAMe,EAAQd,EAAOC,EAAQC,EAAUC,EAAUC,EAAMC,EAAWE,EAAYC,EAAMC,EAAMC,EAAaC,EAAOC,GAAa;;;;;;;OAU7J,IAAIG,EACA,SAASA,EAETC,EAEAC,EAEAC,QACwB,IAAhBA,IAA0BA,GAAc,GAC5CL,KAAKG,OAASA,EACdH,KAAKI,SAAWA,EAChBJ,KAAKK,YAAcA,GAYvBC,EAAoBL,EAAOM,cAAcN,EAAOO,WAAWP,EAAOQ,mBAAmBR,EAAOS,eAL5F,SAASC,EAAYC,GACjBZ,KAAKY,YAAcA,MAIkG,YAAa,GAKtIC,EAA+B,WAC/B,SAASA,KAQT,OANAA,EAAcC,WAAa,CACvB,CAAEC,KAAM7B,EAAK8B,UAAWC,KAAM,CAAC,CACnBC,SAAU,mCACVC,KAAM,CAAEC,MAAS,uBAG1BP,EATuB,GAe9BQ,EAAqC,WACrC,SAASA,KAQT,OANAA,EAAoBP,WAAa,CAC7B,CAAEC,KAAM7B,EAAK8B,UAAWC,KAAM,CAAC,CACnBC,SAAU,gDACVC,KAAM,CAAEC,MAAS,8BAG1BC,EAT6B,GAcpCC,EAAyB,SAAUC,GAEnC,SAASD,EAAQV,EAAaY,EAASlC,EAAUmC,EAEjDC,EAEAC,EAAoBC,EAEpBC,GACI,IAAIC,EAAQP,EAAOQ,KAAK/B,KAAMY,IAAgBZ,KAmC9C,OAlCA8B,EAAMlB,YAAcA,EACpBkB,EAAMN,QAAUA,EAChBM,EAAMH,mBAAqBA,EAE3BG,EAAME,WAAY,EAElBF,EAAMG,oBAAqB,EAE3BH,EAAMI,mBAAoB,EAC1BJ,EAAMK,WAAY,EAClBL,EAAMM,aAAc,EACpBN,EAAMO,YAAa,EAEnBP,EAAMQ,SAAW,IAAI/C,EAAKgD,QAE1BT,EAAMU,QAAU,IAAIjD,EAAKgD,QAEzBT,EAAMW,gBAAkB,IAAIvD,EAAKwD,aAEjCZ,EAAMa,UAAY,IAAIzD,EAAKwD,aAE3BZ,EAAMc,QAAU,IAAI1D,EAAKwD,aACzBZ,EAAMe,oBAINf,EAAMgB,mBAAqBjB,GAAakB,UAAUC,cAAc,OAChElB,EAAMgB,kBAAkBG,UAAUC,IAAI,mBACtCpB,EAAMlB,YAAYuC,cAAcC,YAAYtB,EAAMgB,mBAClDhB,EAAMuB,YAAc,IAAIpD,EAAOqD,eAAexB,EAAON,EAASM,EAAMgB,kBAAmBxD,GACvFwC,EAAMuB,YAAYE,mBAAmB3C,GACrCkB,EAAM0B,aAAe/B,GAAuB,GAC5CK,EAAM2B,oBAAwC,mBAAlB/B,EAC5BI,EAAMF,SAAuB,MAAZA,GAAoB8B,SAAS9B,KAAoB,EAC3DE,EAyPX,OApSA3C,EAAMwE,UAAUrC,EAASC,GA6CzBqC,OAAOC,eAAevC,EAAQwC,UAAW,iBAAkB,CAKvDC,IAAK,WACD,OAAO/D,KAAKgE,UAAYhE,KAAKiE,iBAAmBjE,KAAKwD,aAAaQ,UAEtEE,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAevC,EAAQwC,UAAW,WAAY,CAEjDC,IAAK,WAAc,OAAO/D,KAAKmC,WAC/BiC,IAAK,SAAUC,GACX,IAAIC,EAAejF,EAASkF,sBAAsBF,GAC9CC,IAAiBtE,KAAKmC,YACtBnC,KAAKmC,UAAYmC,EACjBtE,KAAKwE,6BAGbN,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAevC,EAAQwC,UAAW,QAAS,CAE9CC,IAAK,WACD,YAAuBU,IAAhBzE,KAAK0E,OACN1E,KAAK0E,OACL1E,KAAKY,YAAYuC,cAAcwB,aAEzCP,IAAK,SAAUC,GAASrE,KAAK0E,OAASL,GACtCH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAevC,EAAQwC,UAAW,aAAc,CAOnDC,IAAK,WAAc,OAAO/D,KAAKoC,aAAepC,KAAKiC,oBACnDmC,IAAK,SAAUC,GACXrE,KAAKoC,YAAc/C,EAASkF,sBAAsBF,IAEtDH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAevC,EAAQwC,UAAW,YAAa,CAIlDC,IAAK,WAAc,OAAO/D,KAAKqC,YAC/B+B,IAAK,SAAUC,GACXrE,KAAKqC,WAAahD,EAASkF,sBAAsBF,IAErDH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAevC,EAAQwC,UAAW,eAAgB,CAErDC,IAAK,WAGD,OAAO/D,KAAK4E,aAAe5E,KAAKkC,mBAAqBlC,KAAKI,UACtDJ,KAAKI,SAASyE,WAAa,MAEnCX,YAAY,EACZC,cAAc,IAElB7C,EAAQwC,UAAUjB,kBAAoB,WAClC,IACIiC,EAAU9E,KAAKY,YAAYuC,cAC3B2B,EAAQC,aAFY,mBAAA,mBAGpBD,EAAQE,QAAQC,cAChBH,EAAQ7B,UAAUC,IAJE,kBAQpB4B,EAAQ7B,UAAUC,IAAI,sBAG9B5B,EAAQwC,UAAUoB,YAAc,WAC5BlF,KAAK2C,UAAUwC,KAAK,CAAEC,KAAMpF,OAC5BA,KAAKqD,YAAYgC,wBAGrB/D,EAAQwC,UAAUwB,OAAS,WAClBtF,KAAKmC,YACNnC,KAAKmC,WAAY,EACjBnC,KAAKwE,2BACLxE,KAAKuF,kBAIbjE,EAAQwC,UAAU0B,SAAW,WACrBxF,KAAKmC,YACLnC,KAAKmC,WAAY,EACjBnC,KAAKwE,2BACLxE,KAAKuF,kBAIbjE,EAAQwC,UAAU2B,qBAAuB,WAChCzF,KAAKmC,YACNnC,KAAKmC,WAAY,EACjBnC,KAAKwE,0BAAyB,GAC9BxE,KAAKuF,kBAIbjE,EAAQwC,UAAU4B,eAAiB,SAAUrF,GAKzC,YAJoB,IAAhBA,IAA0BA,GAAc,GAC5CL,KAAKmC,WAAanC,KAAKI,SACvBJ,KAAKwE,yBAAyBnE,GAC9BL,KAAKuF,gBACEvF,KAAKI,UAGhBkB,EAAQwC,UAAU6B,MAAQ,WACjB3F,KAAKgC,YACNhC,KAAKY,YAAYuC,cAAcwC,QAC/B3F,KAAKsC,SAASsD,KAAK,CAAER,KAAMpF,QAE/BA,KAAKgC,WAAY,GAQrBV,EAAQwC,UAAU+B,OAAS,WACnB7F,KAAK8F,WACL9F,KAAK4C,QAAQuC,KAAK,CAAEC,KAAMpF,QAIlCsB,EAAQwC,UAAUiC,aAAe,SAAUC,GACnChG,KAAKgE,SACLgC,EAAMC,iBAGND,EAAME,mBAId5E,EAAQwC,UAAUqC,eAAiB,SAAUH,GACzC,IAAIhG,KAAKgE,SAGT,OAAQgC,EAAMI,SACV,KAAKnH,EAASoH,OACd,KAAKpH,EAASqH,UAEVtG,KAAK6F,SAELG,EAAMC,iBACN,MACJ,KAAKhH,EAASsH,MAENvG,KAAK4E,YACL5E,KAAK0F,gBAAe,GAGxBM,EAAMC,mBAIlB3E,EAAQwC,UAAU0C,MAAQ,WACtB,IAAI1E,EAAQ9B,KAKZA,KAAKwB,QAAQiF,SACRC,eACAC,KAAKnH,EAAUoH,KAAK,IACpBC,WAAU,WACX/E,EAAMN,QAAQsF,KAAI,WACdhF,EAAME,WAAY,EAClBF,EAAMU,QAAQoD,KAAK,CAAER,KAAMtD,WAIvCR,EAAQwC,UAAUU,yBAA2B,SAAUnE,QAC/B,IAAhBA,IAA0BA,GAAc,GAC5CL,KAAKyC,gBAAgB0C,KAAK,CACtBhF,OAAQH,KACRK,YAAaA,EACbD,SAAUJ,KAAKmC,aAGvBb,EAAQwC,UAAUyB,cAAgB,WAE1BvF,KAAK2B,oBACL3B,KAAK2B,mBAAmBoF,gBAGhCzF,EAAQR,WAAa,CACjB,CAAEC,KAAM7B,EAAK8B,UAAWC,KAAM,CAAC,CACnBC,SAAU,yDACV8F,OAAQ,CAAC,QAAS,WAAY,gBAAiB,YAC/CC,SAAU,UACV9F,KAAM,CACFC,MAAS,+BACT8F,kBAAmB,6BACnBC,KAAQ,SACRC,4BAA6B,WAC7BC,+BAAgC,SAChCC,sCAAuC,6BACvCC,4BAA6B,WAC7BC,kCAAmC,sBACnCC,kBAAmB,mBACnBC,uBAAwB,sBACxBC,uBAAwB,eACxBC,UAAW,uBACXC,YAAa,yBACbC,UAAW,UACXC,SAAU,eAK9BzG,EAAQ0G,eAAiB,WAAc,MAAO,CAC1C,CAAEjH,KAAM7B,EAAK+I,YACb,CAAElH,KAAM7B,EAAKgJ,QACb,CAAEnH,KAAMzB,EAAS6I,UACjB,CAAEpH,UAAM0D,EAAW3D,WAAY,CAAC,CAAEC,KAAM7B,EAAKkJ,UAAY,CAAErH,KAAM7B,EAAKmJ,OAAQpH,KAAM,CAAChB,EAAOqI,8BAC5F,CAAEvH,KAAMwH,OAAQzH,WAAY,CAAC,CAAEC,KAAM7B,EAAKkJ,UAAY,CAAErH,KAAM7B,EAAKmJ,OAAQpH,KAAM,CAACvB,EAAW8I,0BAC7F,CAAEzH,KAAM7B,EAAKuJ,mBACb,CAAE1H,KAAMwH,OAAQzH,WAAY,CAAC,CAAEC,KAAM7B,EAAKwJ,UAAWzH,KAAM,CAAC,eAC5D,CAAEF,UAAM0D,EAAW3D,WAAY,CAAC,CAAEC,KAAM7B,EAAKkJ,UAAY,CAAErH,KAAM7B,EAAKmJ,OAAQpH,KAAM,CAAC7B,EAAOuJ,eAEhGrH,EAAQsH,eAAiB,CACrBC,OAAQ,CAAC,CAAE9H,KAAM7B,EAAK4J,aAAc7H,KAAM,CAACJ,KAC3CkI,aAAc,CAAC,CAAEhI,KAAM7B,EAAK4J,aAAc7H,KAAM,CAACI,KACjD2H,WAAY,CAAC,CAAEjI,KAAM7B,EAAK4J,aAAc7H,KAAM,CAAC/B,EAAK+J,YAAW,WAAc,OAAOC,QACpF9I,SAAU,CAAC,CAAEW,KAAM7B,EAAKiK,QACxB9E,MAAO,CAAC,CAAEtD,KAAM7B,EAAKiK,QACrBvE,WAAY,CAAC,CAAE7D,KAAM7B,EAAKiK,QAC1BrD,UAAW,CAAC,CAAE/E,KAAM7B,EAAKiK,QACzB1G,gBAAiB,CAAC,CAAE1B,KAAM7B,EAAKkK,SAC/BzG,UAAW,CAAC,CAAE5B,KAAM7B,EAAKkK,SACzBxG,QAAS,CAAC,CAAE7B,KAAM7B,EAAKkK,UAEpB9H,EArSiB,CAsS1BhB,GAcE4I,EAA+B,WAC/B,SAASA,EAAcG,EAEvBC,GACItJ,KAAKqJ,YAAcA,EAEfC,GAAoD,WAAtCA,EAAWnG,cAAcoG,UACvCD,EAAWnG,cAAcqG,aAAa,OAAQ,UA8BtD,OA1BAN,EAAcpF,UAAUiC,aAAe,SAAUC,GAC7C,IAAIyD,EAAazJ,KAAKqJ,YAClBI,EAAW3D,YAAc2D,EAAWzF,UACpCyF,EAAW5D,SAOfG,EAAME,mBAEVgD,EAAcpI,WAAa,CACvB,CAAEC,KAAM7B,EAAK8B,UAAWC,KAAM,CAAC,CACnBC,SAAU,kBACVC,KAAM,CACFC,MAAS,yCACTwG,UAAW,4BAK/BsB,EAAclB,eAAiB,WAAc,MAAO,CAChD,CAAEjH,KAAMO,GACR,CAAEP,KAAM7B,EAAK+I,cAEViB,EArCuB,GAgD9BQ,EAA4B,IAAIxK,EAAKyK,eAAe,6BAsBpDC,EAAwB3J,EAAO4J,iBAV/B,SAASC,EAAgBC,EAA2BC,EAAaC,EAEjEC,GACIlK,KAAK+J,0BAA4BA,EACjC/J,KAAKgK,YAAcA,EACnBhK,KAAKiK,iBAAmBA,EACxBjK,KAAKkK,UAAYA,KAMrBC,EAAe,EAEfC,EACA,SAASA,EAETjK,EAEAkE,GACIrE,KAAKG,OAASA,EACdH,KAAKqE,MAAQA,GAOjBgG,EAA6B,SAAU9I,GAEvC,SAAS8I,EAAYzJ,EAAae,EAAoB2I,EAAMN,EAAaC,EAAkBF,EAE3FG,GACI,IAAIpI,EAAQP,EAAOQ,KAAK/B,KAAM+J,EAA2BC,EAAaC,EAAkBC,IAAclK,KAiDtG,OAhDA8B,EAAMlB,YAAcA,EACpBkB,EAAMH,mBAAqBA,EAC3BG,EAAMwI,KAAOA,EACbxI,EAAMoI,UAAYA,EAKlBpI,EAAMyI,YAAc,gBAMpBzI,EAAM0I,wBAA0B,KAEhC1I,EAAM2I,WAAa,IAAIlL,EAAKgD,QAE5BT,EAAM4I,KAAO,iBAAmBP,IAEhCrI,EAAM6I,UAAY,EAKlB7I,EAAM8I,cAAgB,KAEtB9I,EAAM+I,WAAa,aAEnB/I,EAAMgJ,UAAY,aAClBhJ,EAAMiJ,WAAY,EAClBjJ,EAAMkJ,aAAe,SAAUC,EAAIC,GAAM,OAAOD,IAAOC,GACvDpJ,EAAMqJ,WAAY,EAClBrJ,EAAMsJ,WAAY,EAElBtJ,EAAMuJ,gBAAkB,aACxBvJ,EAAMM,aAAc,EAEpBN,EAAMwJ,OAAS,IAAIpM,EAAKwD,aAMxBZ,EAAMyJ,YAAc,IAAIrM,EAAKwD,aACzBZ,EAAMoI,YACNpI,EAAMoI,UAAUsB,cAAgB1J,GAE7BA,EAwpBX,OA7sBA3C,EAAMwE,UAAU0G,EAAa9I,GAuD7BqC,OAAOC,eAAewG,EAAYvG,UAAW,WAAY,CAErDC,IAAK,WACD,OAAO/D,KAAKyL,SAAWzL,KAAK0L,gBAAgBtL,SAAWJ,KAAK0L,gBAAgBtL,SAAS,IAEzF8D,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,OAAQ,CAEjDC,IAAK,WAAc,OAAO/D,KAAK2L,MAAQ,KAAO,WAC9CzH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,WAAY,CAErDC,IAAK,WAAc,OAAO/D,KAAK+K,WAC/B3G,IAAK,SAAUC,GACXrE,KAAK+K,UAAY1L,EAASkF,sBAAsBF,GAChDrE,KAAK4L,mBAET1H,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,cAAe,CAMxDC,IAAK,WAAc,OAAO/D,KAAKgL,cAC/B5G,IAAK,SAAUyH,GACX7L,KAAKgL,aAAea,EAChB7L,KAAK0L,iBAEL1L,KAAK8L,wBAGb5H,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,QAAS,CAKlDC,IAAK,WAAc,OAAO/D,KAAK0E,QAC/BN,IAAK,SAAUC,GACXrE,KAAK+L,WAAW1H,GAChBrE,KAAK0E,OAASL,GAElBH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,KAAM,CAK/CC,IAAK,WACD,OAAO/D,KAAKgM,WAAahM,KAAKgM,WAAWC,GAAKjM,KAAK0K,MAEvDxG,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,WAAY,CAKrDC,IAAK,WAAc,OAAO/D,KAAKmL,WAC/B/G,IAAK,SAAUC,GACXrE,KAAKmL,UAAY9L,EAASkF,sBAAsBF,GAChDrE,KAAKkM,aAAatG,QAEtB1B,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,cAAe,CAKxDC,IAAK,WACD,OAAO/D,KAAKgM,WAAahM,KAAKgM,WAAWG,YAAcnM,KAAKoM,cAEhEhI,IAAK,SAAUC,GACXrE,KAAKoM,aAAe/H,EACpBrE,KAAKkM,aAAatG,QAEtB1B,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,UAAW,CAEpDC,IAAK,WACD,OAAQ/D,KAAKgM,YAAchM,KAAKgM,WAAWK,SAAYrM,KAAKsM,mBAEhEpI,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,QAAS,CAKlDC,IAAK,WACD,QAAS/D,KAAKgM,YAAchM,KAAKgM,WAAWL,QAAgC,IAAtB3L,KAAKjB,MAAMwN,QAErErI,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,mBAAoB,CAK7DC,IAAK,WAAc,OAAQ/D,KAAK2L,OAAS3L,KAAKqM,SAC9CnI,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,WAAY,CAKrDC,IAAK,WAAc,OAAO/D,KAAKkK,YAAclK,KAAKkK,UAAUlG,SAAWhE,KAAKoL,WAC5EhH,IAAK,SAAUC,GACXrE,KAAKoL,UAAY/L,EAASkF,sBAAsBF,GAChDrE,KAAK4L,mBAET1H,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,aAAc,CAKvDC,IAAK,WAAc,OAAO/D,KAAKoC,aAC/BgC,IAAK,SAAUC,GACX,IAAIvC,EAAQ9B,KACZA,KAAKoC,YAAc/C,EAASkF,sBAAsBF,GAC9CrE,KAAKjB,OACLiB,KAAKjB,MAAMyN,SAAQ,SAAUpH,GAAQ,OAAOA,EAAKnD,mBAAqBH,EAAMM,gBAGpF8B,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,WAAY,CACrDM,IAAK,SAAUC,GACXrE,KAAK4K,cAAgBvG,EACrBrE,KAAK2K,UAAYtG,GAErBH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,uBAAwB,CAEjEC,IAAK,WACD,OAAOxE,EAAKkN,MAAMC,WAAM,EAAQvN,EAAMwN,SAAS3M,KAAKjB,MAAM6N,KAAI,SAAUxH,GAAQ,OAAOA,EAAK3C,sBAEhGyB,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,mBAAoB,CAE7DC,IAAK,WACD,OAAOxE,EAAKkN,MAAMC,WAAM,EAAQvN,EAAMwN,SAAS3M,KAAKjB,MAAM6N,KAAI,SAAUxH,GAAQ,OAAOA,EAAK9C,eAEhG4B,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,kBAAmB,CAE5DC,IAAK,WACD,OAAOxE,EAAKkN,MAAMC,WAAM,EAAQvN,EAAMwN,SAAS3M,KAAKjB,MAAM6N,KAAI,SAAUxH,GAAQ,OAAOA,EAAK5C,cAEhG0B,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAewG,EAAYvG,UAAW,oBAAqB,CAE9DC,IAAK,WACD,OAAOxE,EAAKkN,MAAMC,WAAM,EAAQvN,EAAMwN,SAAS3M,KAAKjB,MAAM6N,KAAI,SAAUxH,GAAQ,OAAOA,EAAKzC,gBAEhGuB,YAAY,EACZC,cAAc,IAElBkG,EAAYvG,UAAU+I,mBAAqB,WACvC,IAAI/K,EAAQ9B,KACZA,KAAK8M,YAAc,IAAInN,EAAKoN,gBAAgB/M,KAAKjB,OAC5CiO,WACAC,0BACAC,0BAA0BlN,KAAKsK,KAAOtK,KAAKsK,KAAKjG,MAAQ,OACzDrE,KAAKsK,MACLtK,KAAKsK,KAAKgB,OACL3E,KAAKnH,EAAU2N,UAAUnN,KAAKyK,aAC9B5D,WAAU,SAAUuG,GAAO,OAAOtL,EAAMgL,YAAYI,0BAA0BE,MAEvFpN,KAAK8M,YAAYO,OAAO1G,KAAKnH,EAAU2N,UAAUnN,KAAKyK,aAAa5D,WAAU,WACzE/E,EAAMwL,uBAGVtN,KAAKjB,MAAMwO,QAAQ5G,KAAKnH,EAAUgO,UAAU,MAAOhO,EAAU2N,UAAUnN,KAAKyK,aAAa5D,WAAU,WAC3F/E,EAAMkC,UAGNyJ,QAAQC,UAAUC,MAAK,WACnB7L,EAAM8J,qBAGd9J,EAAM8L,cAEN9L,EAAMgK,uBAENhK,EAAM+L,kBAEN/L,EAAMgM,gCACNhM,EAAMoK,aAAatG,WAG3ByE,EAAYvG,UAAUiK,SAAW,WAC7B/N,KAAK0L,gBAAkB,IAAI7L,EAAYmO,eAAehO,KAAKyL,cAAUhH,GAAW,GAChFzE,KAAKkM,aAAatG,QAEtByE,EAAYvG,UAAUmK,UAAY,WAC1BjO,KAAKkK,WAILlK,KAAKkO,oBAGb7D,EAAYvG,UAAUoB,YAAc,WAChClF,KAAKyK,WAAW7E,OAChB5F,KAAKyK,WAAW0D,WAChBnO,KAAKkM,aAAaiC,WAClBnO,KAAKoO,sBAGT/D,EAAYvG,UAAUuK,cAAgB,SAAUC,GAC5CtO,KAAKgM,WAAasC,GAMtBjE,EAAYvG,UAAUyK,kBAAoB,SAAUC,GAAOxO,KAAKyO,iBAAmBD,EAAIE,KAAK,MAE5FrE,EAAYvG,UAAUiI,WAAa,SAAU1H,GACrCrE,KAAKjB,OACLiB,KAAK2O,qBAAqBtK,GAAO,IAIzCgG,EAAYvG,UAAU8K,iBAAmB,SAAU/C,GAC/C7L,KAAK8K,UAAYe,GAGrBxB,EAAYvG,UAAU+K,kBAAoB,SAAUhD,GAChD7L,KAAK6K,WAAagB,GAGtBxB,EAAYvG,UAAUgL,iBAAmB,SAAUC,GAC/C/O,KAAKgE,SAAW+K,EAChB/O,KAAKkM,aAAatG,QAMtByE,EAAYvG,UAAUkL,iBAAmB,SAAUhJ,GAC1ChG,KAAKiP,oBAAoBjJ,IAC1BhG,KAAK2F,SAOb0E,EAAYvG,UAAU6B,MAAQ,SAAUuJ,GAChClP,KAAKgE,UAKLhE,KAAKgM,YAAchM,KAAKgM,WAAWK,UAG9BrM,KAAKjB,MAAMwN,OAAS,GACzBvM,KAAK8M,YAAYqC,qBACjBnP,KAAKkM,aAAatG,SAGlB5F,KAAKoP,YAAYF,GACjBlP,KAAKkM,aAAatG,UAI1ByE,EAAYvG,UAAUsL,YAAc,SAAUF,GACtClP,KAAKgM,YACLhM,KAAKgM,WAAWrG,MAAMuJ,IAM9B7E,EAAYvG,UAAUuL,SAAW,SAAUrJ,GACvC,IAAIsJ,EAAStJ,EAAMsJ,OAEftJ,EAAMI,UAAYnH,EAASqH,WAAatG,KAAKuP,cAAcD,IAC3DtP,KAAK8M,YAAY0C,oBACjBxJ,EAAMC,kBAEDqJ,GAAUA,EAAOrM,UAAUwM,SAAS,cACrCzJ,EAAMI,UAAYnH,EAASyQ,MAC3B1P,KAAK8M,YAAYqC,qBACjBnJ,EAAMC,kBAEDD,EAAMI,UAAYnH,EAAS0Q,KAChC3P,KAAK8M,YAAY0C,oBACjBxJ,EAAMC,kBAGNjG,KAAK8M,YAAY8C,UAAU5J,GAE/BhG,KAAKkM,aAAatG,SAM1ByE,EAAYvG,UAAU+J,gBAAkB,WAEpC7N,KAAK2K,UAAY3K,KAAK4K,gBAAwC,IAAtB5K,KAAKjB,MAAMwN,QAAgB,EAAI,IAM3ElC,EAAYvG,UAAUgK,8BAAgC,WAElD,GAAoC,MAAhC9N,KAAKwK,wBACL,GAAIxK,KAAKjB,MAAMwN,OAAQ,CACnB,IAAIsD,EAAeC,KAAKC,IAAI/P,KAAKwK,wBAAyBxK,KAAKjB,MAAMwN,OAAS,GAC9EvM,KAAK8M,YAAYkD,cAAcH,QAG/B7P,KAAK2F,QAGb3F,KAAKwK,wBAA0B,MAQnCH,EAAYvG,UAAUmM,cAAgB,SAAUC,GAC5C,OAAOA,GAAS,GAAKA,EAAQlQ,KAAKjB,MAAMwN,QAE5ClC,EAAYvG,UAAUyL,cAAgB,SAAUzK,GAC5C,SAAIA,GAA8C,UAAnCA,EAAQyE,SAAStE,eAChBH,EACET,QAItBgG,EAAYvG,UAAU6K,qBAAuB,SAAUtK,EAAOhE,GAC1D,IAAIyB,EAAQ9B,KAIZ,QAHoB,IAAhBK,IAA0BA,GAAc,GAC5CL,KAAKmQ,kBACLnQ,KAAKjB,MAAMyN,SAAQ,SAAUpH,GAAQ,OAAOA,EAAKI,cAC7C4K,MAAMC,QAAQhM,GACdA,EAAMmI,SAAQ,SAAU8D,GAAgB,OAAOxO,EAAMyO,aAAaD,EAAcjQ,MAChFL,KAAKwQ,kBAEJ,CACD,IAAIC,EAAoBzQ,KAAKuQ,aAAalM,EAAOhE,GAG7CoQ,GACIpQ,GACAL,KAAK8M,YAAYkD,cAAcS,KAS/CpG,EAAYvG,UAAUyM,aAAe,SAAUlM,EAAOhE,GAClD,IAAIyB,EAAQ9B,UACQ,IAAhBK,IAA0BA,GAAc,GAC5C,IAAIoQ,EAAoBzQ,KAAKjB,MAAM2R,MAAK,SAAUtL,GAC9C,OAAqB,MAAdA,EAAKf,OAAiBvC,EAAMkJ,aAAa5F,EAAKf,MAAOA,MAMhE,OAJIoM,IACApQ,EAAcoQ,EAAkBhL,uBAAyBgL,EAAkBnL,SAC3EtF,KAAK0L,gBAAgBpG,OAAOmL,IAEzBA,GAEXpG,EAAYvG,UAAUgI,qBAAuB,WACzC,IAAIhK,EAAQ9B,KAGZyN,QAAQC,UAAUC,MAAK,YACf7L,EAAMoI,WAAapI,EAAM4C,UACzB5C,EAAM6M,qBAAqB7M,EAAMoI,UAAYpI,EAAMoI,UAAU7F,MAAQvC,EAAM4C,QAAQ,GACnF5C,EAAMoK,aAAatG,YAQ/ByE,EAAYvG,UAAUqM,gBAAkB,SAAUQ,GAC9C3Q,KAAK0L,gBAAgBkF,QACrB5Q,KAAKjB,MAAMyN,SAAQ,SAAUpH,GACrBA,IAASuL,GACTvL,EAAKI,cAGbxF,KAAKkM,aAAatG,QAMtByE,EAAYvG,UAAU0M,YAAc,WAChC,IAAI1O,EAAQ9B,KACRA,KAAK+K,YACL/K,KAAK0L,gBAAgBkF,QACrB5Q,KAAKjB,MAAMyN,SAAQ,SAAUpH,GACrBA,EAAKhF,UACL0B,EAAM4J,gBAAgBpG,OAAOF,MAGrCpF,KAAKkM,aAAatG,SAI1ByE,EAAYvG,UAAU+M,kBAAoB,SAAUC,GAChD,IAAIC,EAEAA,EADAX,MAAMC,QAAQrQ,KAAKI,UACLJ,KAAKI,SAASwM,KAAI,SAAUxH,GAAQ,OAAOA,EAAKf,SAGhDrE,KAAKI,SAAWJ,KAAKI,SAASiE,MAAQyM,EAExD9Q,KAAK0E,OAASqM,EACd/Q,KAAKsL,OAAOnG,KAAK,IAAIiF,EAAkBpK,KAAM+Q,IAC7C/Q,KAAKuL,YAAYpG,KAAK4L,GACtB/Q,KAAK8K,UAAUiG,GACf/Q,KAAK2B,mBAAmBoF,gBAG5BsD,EAAYvG,UAAU0C,MAAQ,WAC1B,IAAI1E,EAAQ9B,KACPA,KAAKsM,mBACNtM,KAAK8M,YAAYkD,eAAe,GAE/BhQ,KAAKgE,WACFhE,KAAKgM,WAKLgF,YAAW,WACFlP,EAAMuK,SACPvK,EAAMmP,oBAMdjR,KAAKiR,mBAKjB5G,EAAYvG,UAAUmN,eAAiB,WACnCjR,KAAK6K,aACL7K,KAAK2B,mBAAmBoF,eACxB/G,KAAKkM,aAAatG,QAOtByE,EAAYvG,UAAUwJ,kBAAoB,WACtC,IAAIxL,EAAQ9B,MACY,IAApBA,KAAK2K,YACL3K,KAAK2K,WAAa,EAClBqG,YAAW,WACPlP,EAAM6I,UAAY7I,EAAM8I,eAAiB,EACzC9I,EAAMH,mBAAmBoF,oBAIrCsD,EAAYvG,UAAU8J,YAAc,WAChC5N,KAAKoO,qBACLpO,KAAKkR,sBACLlR,KAAKmR,0BACLnR,KAAKoR,yBAET/G,EAAYvG,UAAUsK,mBAAqB,WACnCpO,KAAKqR,yBACLrR,KAAKqR,uBAAuBC,cAC5BtR,KAAKqR,uBAAyB,MAE9BrR,KAAKuR,wBACLvR,KAAKuR,sBAAsBD,cAC3BtR,KAAKuR,sBAAwB,MAE7BvR,KAAKwR,6BACLxR,KAAKwR,2BAA2BF,cAChCtR,KAAKwR,2BAA6B,MAElCxR,KAAKyR,0BACLzR,KAAKyR,wBAAwBH,cAC7BtR,KAAKyR,wBAA0B,OAIvCpH,EAAYvG,UAAUqN,wBAA0B,WAC5C,IAAIrP,EAAQ9B,KACZA,KAAKwR,2BAA6BxR,KAAK0R,qBAAqB7K,WAAU,SAAUb,GAC5EA,EAAM7F,OAAOC,SACP0B,EAAM4J,gBAAgBpG,OAAOU,EAAM7F,QACnC2B,EAAM4J,gBAAgBlG,SAASQ,EAAM7F,QAEtC2B,EAAM2J,UACP3J,EAAM/C,MAAMyN,SAAQ,SAAUpH,IACrBtD,EAAM4J,gBAAgBiG,WAAWvM,IAASA,EAAKhF,UAChDgF,EAAKI,cAIbQ,EAAM3F,aACNyB,EAAM+O,wBAKlBxG,EAAYvG,UAAUoN,oBAAsB,WACxC,IAAIpP,EAAQ9B,KACZA,KAAKqR,uBAAyBrR,KAAK4R,iBAAiB/K,WAAU,SAAUb,GACpE,IAAI6L,EAAY/P,EAAM/C,MAAM+S,UAAUC,QAAQ/L,EAAMZ,MAChDtD,EAAMmO,cAAc4B,IACpB/P,EAAMgL,YAAYkF,iBAAiBH,GAEvC/P,EAAMoK,aAAatG,UAEvB5F,KAAKuR,sBAAwBvR,KAAKiS,gBAAgBpL,WAAU,WACxD/E,EAAM0E,QACN1E,EAAMoK,aAAatG,WAG3ByE,EAAYvG,UAAUsN,sBAAwB,WAC1C,IAAItP,EAAQ9B,KACZA,KAAKyR,wBAA0BzR,KAAKkS,kBAAkBrL,WAAU,SAAUb,GACtE,IAAIZ,EAAOY,EAAMZ,KACbyM,EAAY/P,EAAM/C,MAAM+S,UAAUC,QAAQ/L,EAAMZ,MAIhDtD,EAAMmO,cAAc4B,IAAczM,EAAKpD,YACvCF,EAAM0I,wBAA0BqH,OAK5CxH,EAAYvG,UAAUmL,oBAAsB,SAAUjJ,GAElD,IADA,IAAImM,EAAiBnM,EAAMsJ,OACpB6C,GAAkBA,IAAmBnS,KAAKY,YAAYuC,eAAe,CACxE,GAAIgP,EAAelP,UAAUwM,SAAS,YAClC,OAAO,EAEX0C,EAAiBA,EAAeC,cAEpC,OAAO,GAGX/H,EAAYvG,UAAUwI,gBAAkB,WACpC,OAAOtM,KAAKjB,MAAMsT,MAAK,SAAUjN,GAAQ,OAAOA,EAAKpD,cAGzDqI,EAAYvG,UAAU8H,gBAAkB,WACpC,IAAI9J,EAAQ9B,KACRA,KAAKjB,OACLiB,KAAKjB,MAAMyN,SAAQ,SAAUpH,GACzBA,EAAKpB,SAAWlC,EAAMsJ,UACtBhG,EAAKlD,kBAAoBJ,EAAM2J,aAI3CpB,EAAYvJ,WAAa,CACrB,CAAEC,KAAM7B,EAAKoT,UAAWrR,KAAM,CAAC,CACnBC,SAAU,gBACVqR,SAAU,qEACVtL,SAAU,cACV9F,KAAM,CACF+F,kBAAmB,8BACnBsL,0BAA2B,2BAC3BC,uBAAwB,yBACxB/K,uBAAwB,sBACxBgL,sBAAuB,aACvBC,8BAA+B,WAC/BC,cAAe,OACfC,iCAAkC,WAClCC,gCAAiC,aACjCC,iCAAkC,WAClCC,0BAA2B,kBAC3B5R,MAAS,gBACT0G,UAAW,UACXC,SAAU,UACVF,YAAa,mBACboL,OAAQ,QAEZC,UAAW,CAAC,CAAEC,QAASpT,EAAUqT,oBAAqBC,YAAahJ,IACnEiJ,cAAepU,EAAKqU,kBAAkBC,KACtCC,gBAAiBvU,EAAKwU,wBAAwBC,OAC9CC,OAAQ,CAAC,igGAIzBvJ,EAAYrC,eAAiB,WAAc,MAAO,CAC9C,CAAEjH,KAAM7B,EAAK+I,YACb,CAAElH,KAAM7B,EAAKuJ,mBACb,CAAE1H,KAAMnB,EAAKiU,eAAgB/S,WAAY,CAAC,CAAEC,KAAM7B,EAAKkJ,YACvD,CAAErH,KAAMjB,EAAMgU,OAAQhT,WAAY,CAAC,CAAEC,KAAM7B,EAAKkJ,YAChD,CAAErH,KAAMjB,EAAMiU,mBAAoBjT,WAAY,CAAC,CAAEC,KAAM7B,EAAKkJ,YAC5D,CAAErH,KAAMd,EAAO+T,mBACf,CAAEjT,KAAMjB,EAAMmU,UAAWnT,WAAY,CAAC,CAAEC,KAAM7B,EAAKkJ,UAAY,CAAErH,KAAM7B,EAAKgV,UAEhF7J,EAAYzB,eAAiB,CACzBuL,kBAAmB,CAAC,CAAEpT,KAAM7B,EAAKiK,QACjCsC,SAAU,CAAC,CAAE1K,KAAM7B,EAAKiK,QACxBiL,YAAa,CAAC,CAAErT,KAAM7B,EAAKiK,QAC3B9E,MAAO,CAAC,CAAEtD,KAAM7B,EAAKiK,QACrBkL,SAAU,CAAC,CAAEtT,KAAM7B,EAAKiK,QACxBgD,YAAa,CAAC,CAAEpL,KAAM7B,EAAKiK,QAC3BnF,SAAU,CAAC,CAAEjD,KAAM7B,EAAKiK,QACxBkC,gBAAiB,CAAC,CAAEtK,KAAM7B,EAAKiK,MAAOlI,KAAM,CAAC,sBAC7C2D,WAAY,CAAC,CAAE7D,KAAM7B,EAAKiK,QAC1BvH,SAAU,CAAC,CAAEb,KAAM7B,EAAKiK,QACxBmC,OAAQ,CAAC,CAAEvK,KAAM7B,EAAKkK,SACtBmC,YAAa,CAAC,CAAExK,KAAM7B,EAAKkK,SAC3BrK,MAAO,CAAC,CAAEgC,KAAM7B,EAAKoV,gBAAiBrT,KAAM,CAACK,EAAS,CAGtCiT,aAAa,OAG1BlK,EA9sBqB,CA+sB9BT,GAUE4K,EAAiB,EAKjBC,EAA8B,WAC9B,SAASA,EAAa7T,EAAa8T,GAC/B1U,KAAKY,YAAcA,EACnBZ,KAAK0U,gBAAkBA,EAEvB1U,KAAKqM,SAAU,EACfrM,KAAK2U,YAAa,EAMlB3U,KAAK4U,kBAAoB5U,KAAK0U,gBAAgBE,kBAE9C5U,KAAK6U,QAAU,IAAI3V,EAAKwD,aAExB1C,KAAKmM,YAAc,GAEnBnM,KAAKiM,GAAK,uBAAyBuI,IACnCxU,KAAKoL,WAAY,EACjBpL,KAAK8U,cAAgB9U,KAAKY,YAAYuC,cA4H1C,OA1HAS,OAAOC,eAAe4Q,EAAa3Q,UAAW,WAAY,CAEtDM,IAAK,SAAUC,GACPA,IACArE,KAAK+U,UAAY1Q,EACjBrE,KAAK+U,UAAU1G,cAAcrO,QAGrCkE,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAe4Q,EAAa3Q,UAAW,YAAa,CAIvDC,IAAK,WAAc,OAAO/D,KAAK2U,YAC/BvQ,IAAK,SAAUC,GAASrE,KAAK2U,WAAatV,EAASkF,sBAAsBF,IACzEH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAe4Q,EAAa3Q,UAAW,WAAY,CAEtDC,IAAK,WAAc,OAAO/D,KAAKoL,WAAcpL,KAAK+U,WAAa/U,KAAK+U,UAAU/Q,UAC9EI,IAAK,SAAUC,GAASrE,KAAKoL,UAAY/L,EAASkF,sBAAsBF,IACxEH,YAAY,EACZC,cAAc,IAElBP,OAAOC,eAAe4Q,EAAa3Q,UAAW,QAAS,CAEnDC,IAAK,WAAc,OAAQ/D,KAAK8U,cAAczQ,OAC9CH,YAAY,EACZC,cAAc,IAElBsQ,EAAa3Q,UAAUkR,YAAc,WACjChV,KAAK+U,UAAU7I,aAAatG,QAGhC6O,EAAa3Q,UAAUuL,SAAW,SAAUrJ,GAGpCA,GAASA,EAAMI,UAAYnH,EAASgW,MAAQhW,EAASiW,eAAelP,EAAO,aAC3EhG,KAAK+U,UAAUzH,oBAEnBtN,KAAKmV,aAAanP,IAGtByO,EAAa3Q,UAAU0C,MAAQ,WACvBxG,KAAKoV,WACLpV,KAAKmV,eAETnV,KAAKqM,SAAU,EAEVrM,KAAK+U,UAAU1I,SAChBrM,KAAK+U,UAAUvO,QAEnBxG,KAAK+U,UAAU7I,aAAatG,QAEhC6O,EAAa3Q,UAAUuR,OAAS,WAC5BrV,KAAKqM,SAAU,EACfrM,KAAK+U,UAAU7I,aAAatG,QAGhC6O,EAAa3Q,UAAUqR,aAAe,SAAUnP,IACvChG,KAAK8U,cAAczQ,OAAW2B,GAC/BhG,KAAK+U,UAAU1F,SAASrJ,GAEvBA,IAAShG,KAAKsV,gBAAgBtP,KAC/BhG,KAAK6U,QAAQ1P,KAAK,CAAEoQ,MAAOvV,KAAK8U,cAAezQ,MAAOrE,KAAK8U,cAAczQ,QACrE2B,GACAA,EAAMC,mBAIlBwO,EAAa3Q,UAAU0R,SAAW,WAE9BxV,KAAK+U,UAAU7I,aAAatG,QAGhC6O,EAAa3Q,UAAU6B,MAAQ,SAAUuJ,GACrClP,KAAK8U,cAAcnP,MAAMuJ,IAG7BuF,EAAa3Q,UAAUwR,gBAAkB,SAAUtP,GAC/C,GAAI/G,EAASiW,eAAelP,GACxB,OAAO,EAEX,IAAIyP,EAAazV,KAAK4U,kBAClBxO,EAAUJ,EAAMI,QACpB,OAAOgK,MAAMC,QAAQoF,GAAcA,EAAW1D,QAAQ3L,IAAY,EAAIqP,EAAWC,IAAItP,IAEzFqO,EAAa3T,WAAa,CACtB,CAAEC,KAAM7B,EAAK8B,UAAWC,KAAM,CAAC,CACnBC,SAAU,yBACV+F,SAAU,gCACV9F,KAAM,CACFC,MAAS,mCACTyG,YAAa,mBACbE,SAAU,UACVD,UAAW,WACX6N,UAAW,aACX1C,OAAQ,KACRxL,kBAAmB,mBACnBmO,qBAAsB,sBACtBlD,sBAAuB,wEACvBD,uBAAwB,+CAK5CgC,EAAazM,eAAiB,WAAc,MAAO,CAC/C,CAAEjH,KAAM7B,EAAK+I,YACb,CAAElH,UAAM0D,EAAW3D,WAAY,CAAC,CAAEC,KAAM7B,EAAKmJ,OAAQpH,KAAM,CAACyI,QAEhE+K,EAAa7L,eAAiB,CAC1BiN,SAAU,CAAC,CAAE9U,KAAM7B,EAAKiK,MAAOlI,KAAM,CAAC,qBACtCmU,UAAW,CAAC,CAAErU,KAAM7B,EAAKiK,MAAOlI,KAAM,CAAC,2BACvC2T,kBAAmB,CAAC,CAAE7T,KAAM7B,EAAKiK,MAAOlI,KAAM,CAAC,mCAC/C4T,QAAS,CAAC,CAAE9T,KAAM7B,EAAKkK,OAAQnI,KAAM,CAAC,0BACtCkL,YAAa,CAAC,CAAEpL,KAAM7B,EAAKiK,QAC3B8C,GAAI,CAAC,CAAElL,KAAM7B,EAAKiK,QAClBnF,SAAU,CAAC,CAAEjD,KAAM7B,EAAKiK,SAErBsL,EAhJsB,GA0J7BqB,EAAoB,CACpBzL,EACA/I,EACAmT,EACAvL,EACArI,EACAQ,GAEA0U,EAAK,CACLnB,kBAAmB,CAAC3V,EAAS+W,QAE7BC,EAAgC,WAChC,SAASA,KAeT,OAbAA,EAAenV,WAAa,CACxB,CAAEC,KAAM7B,EAAKgX,SAAUjV,KAAM,CAAC,CAClB1C,QAASuX,EACTK,aAAcL,EACd5C,UAAW,CACPjT,EAAO+T,kBACP,CACIb,QAASzJ,EACT0M,SAAUL,QAK3BE,EAhBwB;;;;;;;;AA+BnC1X,EAAQmL,0BAA4BA,EACpCnL,EAAQ+C,QAAUA,EAClB/C,EAAQsC,cAAgBA,EACxBtC,EAAQkW,aAAeA,EACvBlW,EAAQ8L,YAAcA,EACtB9L,EAAQ6L,kBAAoBA,EAC5B7L,EAAQ2K,cAAgBA,EACxB3K,EAAQ2B,uBAAyBA,EACjC3B,EAAQ8C,oBAAsBA,EAC9B9C,EAAQ0X,eAAiBA,EACzB1X,EAAQwX,GAAKA,EAEbnS,OAAOC,eAAetF,EAAS,aAAc,CAAE8F,OAAO","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/cdk/keycodes'), require('@angular/core'), require('@angular/material/core'), require('tslib'), require('@angular/common'), require('@angular/cdk/coercion'), require('@angular/cdk/platform'), require('rxjs'), require('rxjs/operators'), require('@angular/platform-browser/animations'), require('@angular/cdk/a11y'), require('@angular/cdk/bidi'), require('@angular/cdk/collections'), require('@angular/forms'), require('@angular/material/form-field')) :\n    typeof define === 'function' && define.amd ? define('@angular/material/chips', ['exports', '@angular/cdk/keycodes', '@angular/core', '@angular/material/core', 'tslib', '@angular/common', '@angular/cdk/coercion', '@angular/cdk/platform', 'rxjs', 'rxjs/operators', '@angular/platform-browser/animations', '@angular/cdk/a11y', '@angular/cdk/bidi', '@angular/cdk/collections', '@angular/forms', '@angular/material/form-field'], factory) :\n    (global = global || self, factory((global.ng = global.ng || {}, global.ng.material = global.ng.material || {}, global.ng.material.chips = {}), global.ng.cdk.keycodes, global.ng.core, global.ng.material.core, global.tslib, global.ng.common, global.ng.cdk.coercion, global.ng.cdk.platform, global.rxjs, global.rxjs.operators, global.ng.platformBrowser.animations, global.ng.cdk.a11y, global.ng.cdk.bidi, global.ng.cdk.collections, global.ng.forms, global.ng.material.formField));\n}(this, (function (exports, keycodes, core, core$1, tslib, common, coercion, platform, rxjs, operators, animations, a11y, bidi, collections, forms, formField) { 'use strict';\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Event object emitted by MatChip when selected or deselected. */\n    var MatChipSelectionChange = /** @class */ (function () {\n        function MatChipSelectionChange(\n        /** Reference to the chip that emitted the event. */\n        source, \n        /** Whether the chip that emitted the event is selected. */\n        selected, \n        /** Whether the selection change was a result of a user interaction. */\n        isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this.source = source;\n            this.selected = selected;\n            this.isUserInput = isUserInput;\n        }\n        return MatChipSelectionChange;\n    }());\n    // Boilerplate for applying mixins to MatChip.\n    /** @docs-private */\n    var MatChipBase = /** @class */ (function () {\n        function MatChipBase(_elementRef) {\n            this._elementRef = _elementRef;\n        }\n        return MatChipBase;\n    }());\n    var _MatChipMixinBase = core$1.mixinTabIndex(core$1.mixinColor(core$1.mixinDisableRipple(core$1.mixinDisabled(MatChipBase)), 'primary'), -1);\n    /**\n     * Dummy directive to add CSS class to chip avatar.\n     * @docs-private\n     */\n    var MatChipAvatar = /** @class */ (function () {\n        function MatChipAvatar() {\n        }\n        MatChipAvatar.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-chip-avatar, [matChipAvatar]',\n                        host: { 'class': 'mat-chip-avatar' }\n                    },] }\n        ];\n        return MatChipAvatar;\n    }());\n    /**\n     * Dummy directive to add CSS class to chip trailing icon.\n     * @docs-private\n     */\n    var MatChipTrailingIcon = /** @class */ (function () {\n        function MatChipTrailingIcon() {\n        }\n        MatChipTrailingIcon.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'mat-chip-trailing-icon, [matChipTrailingIcon]',\n                        host: { 'class': 'mat-chip-trailing-icon' }\n                    },] }\n        ];\n        return MatChipTrailingIcon;\n    }());\n    /**\n     * Material design styled Chip component. Used inside the MatChipList component.\n     */\n    var MatChip = /** @class */ (function (_super) {\n        tslib.__extends(MatChip, _super);\n        function MatChip(_elementRef, _ngZone, platform, globalRippleOptions, \n        // @breaking-change 8.0.0 `animationMode` parameter to become required.\n        animationMode, \n        // @breaking-change 9.0.0 `_changeDetectorRef` parameter to become required.\n        _changeDetectorRef, tabIndex, \n        // @breaking-change 11.0.0 `_document` parameter to become required.\n        _document) {\n            var _this = _super.call(this, _elementRef) || this;\n            _this._elementRef = _elementRef;\n            _this._ngZone = _ngZone;\n            _this._changeDetectorRef = _changeDetectorRef;\n            /** Whether the chip has focus. */\n            _this._hasFocus = false;\n            /** Whether the chip list is selectable */\n            _this.chipListSelectable = true;\n            /** Whether the chip list is in multi-selection mode. */\n            _this._chipListMultiple = false;\n            _this._selected = false;\n            _this._selectable = true;\n            _this._removable = true;\n            /** Emits when the chip is focused. */\n            _this._onFocus = new rxjs.Subject();\n            /** Emits when the chip is blured. */\n            _this._onBlur = new rxjs.Subject();\n            /** Emitted when the chip is selected or deselected. */\n            _this.selectionChange = new core.EventEmitter();\n            /** Emitted when the chip is destroyed. */\n            _this.destroyed = new core.EventEmitter();\n            /** Emitted when a chip is to be removed. */\n            _this.removed = new core.EventEmitter();\n            _this._addHostClassName();\n            // Dynamically create the ripple target, append it within the chip, and use it as the\n            // chip's ripple target. Adding the class '.mat-chip-ripple' ensures that it will have\n            // the proper styles.\n            _this._chipRippleTarget = (_document || document).createElement('div');\n            _this._chipRippleTarget.classList.add('mat-chip-ripple');\n            _this._elementRef.nativeElement.appendChild(_this._chipRippleTarget);\n            _this._chipRipple = new core$1.RippleRenderer(_this, _ngZone, _this._chipRippleTarget, platform);\n            _this._chipRipple.setupTriggerEvents(_elementRef);\n            _this.rippleConfig = globalRippleOptions || {};\n            _this._animationsDisabled = animationMode === 'NoopAnimations';\n            _this.tabIndex = tabIndex != null ? (parseInt(tabIndex) || -1) : -1;\n            return _this;\n        }\n        Object.defineProperty(MatChip.prototype, \"rippleDisabled\", {\n            /**\n             * Whether ripples are disabled on interaction\n             * @docs-private\n             */\n            get: function () {\n                return this.disabled || this.disableRipple || !!this.rippleConfig.disabled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"selected\", {\n            /** Whether the chip is selected. */\n            get: function () { return this._selected; },\n            set: function (value) {\n                var coercedValue = coercion.coerceBooleanProperty(value);\n                if (coercedValue !== this._selected) {\n                    this._selected = coercedValue;\n                    this._dispatchSelectionChange();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"value\", {\n            /** The value of the chip. Defaults to the content inside `<mat-chip>` tags. */\n            get: function () {\n                return this._value !== undefined\n                    ? this._value\n                    : this._elementRef.nativeElement.textContent;\n            },\n            set: function (value) { this._value = value; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"selectable\", {\n            /**\n             * Whether or not the chip is selectable. When a chip is not selectable,\n             * changes to its selected state are always ignored. By default a chip is\n             * selectable, and it becomes non-selectable if its parent chip list is\n             * not selectable.\n             */\n            get: function () { return this._selectable && this.chipListSelectable; },\n            set: function (value) {\n                this._selectable = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"removable\", {\n            /**\n             * Determines whether or not the chip displays the remove styling and emits (removed) events.\n             */\n            get: function () { return this._removable; },\n            set: function (value) {\n                this._removable = coercion.coerceBooleanProperty(value);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChip.prototype, \"ariaSelected\", {\n            /** The ARIA selected applied to the chip. */\n            get: function () {\n                // Remove the `aria-selected` when the chip is deselected in single-selection mode, because\n                // it adds noise to NVDA users where \"not selected\" will be read out for each chip.\n                return this.selectable && (this._chipListMultiple || this.selected) ?\n                    this.selected.toString() : null;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatChip.prototype._addHostClassName = function () {\n            var basicChipAttrName = 'mat-basic-chip';\n            var element = this._elementRef.nativeElement;\n            if (element.hasAttribute(basicChipAttrName) ||\n                element.tagName.toLowerCase() === basicChipAttrName) {\n                element.classList.add(basicChipAttrName);\n                return;\n            }\n            else {\n                element.classList.add('mat-standard-chip');\n            }\n        };\n        MatChip.prototype.ngOnDestroy = function () {\n            this.destroyed.emit({ chip: this });\n            this._chipRipple._removeTriggerEvents();\n        };\n        /** Selects the chip. */\n        MatChip.prototype.select = function () {\n            if (!this._selected) {\n                this._selected = true;\n                this._dispatchSelectionChange();\n                this._markForCheck();\n            }\n        };\n        /** Deselects the chip. */\n        MatChip.prototype.deselect = function () {\n            if (this._selected) {\n                this._selected = false;\n                this._dispatchSelectionChange();\n                this._markForCheck();\n            }\n        };\n        /** Select this chip and emit selected event */\n        MatChip.prototype.selectViaInteraction = function () {\n            if (!this._selected) {\n                this._selected = true;\n                this._dispatchSelectionChange(true);\n                this._markForCheck();\n            }\n        };\n        /** Toggles the current selected state of this chip. */\n        MatChip.prototype.toggleSelected = function (isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this._selected = !this.selected;\n            this._dispatchSelectionChange(isUserInput);\n            this._markForCheck();\n            return this.selected;\n        };\n        /** Allows for programmatic focusing of the chip. */\n        MatChip.prototype.focus = function () {\n            if (!this._hasFocus) {\n                this._elementRef.nativeElement.focus();\n                this._onFocus.next({ chip: this });\n            }\n            this._hasFocus = true;\n        };\n        /**\n         * Allows for programmatic removal of the chip. Called by the MatChipList when the DELETE or\n         * BACKSPACE keys are pressed.\n         *\n         * Informs any listeners of the removal request. Does not remove the chip from the DOM.\n         */\n        MatChip.prototype.remove = function () {\n            if (this.removable) {\n                this.removed.emit({ chip: this });\n            }\n        };\n        /** Handles click events on the chip. */\n        MatChip.prototype._handleClick = function (event) {\n            if (this.disabled) {\n                event.preventDefault();\n            }\n            else {\n                event.stopPropagation();\n            }\n        };\n        /** Handle custom key presses. */\n        MatChip.prototype._handleKeydown = function (event) {\n            if (this.disabled) {\n                return;\n            }\n            switch (event.keyCode) {\n                case keycodes.DELETE:\n                case keycodes.BACKSPACE:\n                    // If we are removable, remove the focused chip\n                    this.remove();\n                    // Always prevent so page navigation does not occur\n                    event.preventDefault();\n                    break;\n                case keycodes.SPACE:\n                    // If we are selectable, toggle the focused chip\n                    if (this.selectable) {\n                        this.toggleSelected(true);\n                    }\n                    // Always prevent space from scrolling the page since the list has focus\n                    event.preventDefault();\n                    break;\n            }\n        };\n        MatChip.prototype._blur = function () {\n            var _this = this;\n            // When animations are enabled, Angular may end up removing the chip from the DOM a little\n            // earlier than usual, causing it to be blurred and throwing off the logic in the chip list\n            // that moves focus not the next item. To work around the issue, we defer marking the chip\n            // as not focused until the next time the zone stabilizes.\n            this._ngZone.onStable\n                .asObservable()\n                .pipe(operators.take(1))\n                .subscribe(function () {\n                _this._ngZone.run(function () {\n                    _this._hasFocus = false;\n                    _this._onBlur.next({ chip: _this });\n                });\n            });\n        };\n        MatChip.prototype._dispatchSelectionChange = function (isUserInput) {\n            if (isUserInput === void 0) { isUserInput = false; }\n            this.selectionChange.emit({\n                source: this,\n                isUserInput: isUserInput,\n                selected: this._selected\n            });\n        };\n        MatChip.prototype._markForCheck = function () {\n            // @breaking-change 9.0.0 Remove this method once the _changeDetectorRef is a required param.\n            if (this._changeDetectorRef) {\n                this._changeDetectorRef.markForCheck();\n            }\n        };\n        MatChip.decorators = [\n            { type: core.Directive, args: [{\n                        selector: \"mat-basic-chip, [mat-basic-chip], mat-chip, [mat-chip]\",\n                        inputs: ['color', 'disabled', 'disableRipple', 'tabIndex'],\n                        exportAs: 'matChip',\n                        host: {\n                            'class': 'mat-chip mat-focus-indicator',\n                            '[attr.tabindex]': 'disabled ? null : tabIndex',\n                            'role': 'option',\n                            '[class.mat-chip-selected]': 'selected',\n                            '[class.mat-chip-with-avatar]': 'avatar',\n                            '[class.mat-chip-with-trailing-icon]': 'trailingIcon || removeIcon',\n                            '[class.mat-chip-disabled]': 'disabled',\n                            '[class._mat-animation-noopable]': '_animationsDisabled',\n                            '[attr.disabled]': 'disabled || null',\n                            '[attr.aria-disabled]': 'disabled.toString()',\n                            '[attr.aria-selected]': 'ariaSelected',\n                            '(click)': '_handleClick($event)',\n                            '(keydown)': '_handleKeydown($event)',\n                            '(focus)': 'focus()',\n                            '(blur)': '_blur()',\n                        },\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChip.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.NgZone },\n            { type: platform.Platform },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [core$1.MAT_RIPPLE_GLOBAL_OPTIONS,] }] },\n            { type: String, decorators: [{ type: core.Optional }, { type: core.Inject, args: [animations.ANIMATION_MODULE_TYPE,] }] },\n            { type: core.ChangeDetectorRef },\n            { type: String, decorators: [{ type: core.Attribute, args: ['tabindex',] }] },\n            { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [common.DOCUMENT,] }] }\n        ]; };\n        MatChip.propDecorators = {\n            avatar: [{ type: core.ContentChild, args: [MatChipAvatar,] }],\n            trailingIcon: [{ type: core.ContentChild, args: [MatChipTrailingIcon,] }],\n            removeIcon: [{ type: core.ContentChild, args: [core.forwardRef(function () { return MatChipRemove; }),] }],\n            selected: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            selectable: [{ type: core.Input }],\n            removable: [{ type: core.Input }],\n            selectionChange: [{ type: core.Output }],\n            destroyed: [{ type: core.Output }],\n            removed: [{ type: core.Output }]\n        };\n        return MatChip;\n    }(_MatChipMixinBase));\n    /**\n     * Applies proper (click) support and adds styling for use with the Material Design \"cancel\" icon\n     * available at https://material.io/icons/#ic_cancel.\n     *\n     * Example:\n     *\n     *     `<mat-chip>\n     *       <mat-icon matChipRemove>cancel</mat-icon>\n     *     </mat-chip>`\n     *\n     * You *may* use a custom icon, but you may need to override the `mat-chip-remove` positioning\n     * styles to properly center the icon within the chip.\n     */\n    var MatChipRemove = /** @class */ (function () {\n        function MatChipRemove(_parentChip, \n        // @breaking-change 11.0.0 `elementRef` parameter to be made required.\n        elementRef) {\n            this._parentChip = _parentChip;\n            // @breaking-change 11.0.0 Remove null check for `elementRef`.\n            if (elementRef && elementRef.nativeElement.nodeName === 'BUTTON') {\n                elementRef.nativeElement.setAttribute('type', 'button');\n            }\n        }\n        /** Calls the parent chip's public `remove()` method if applicable. */\n        MatChipRemove.prototype._handleClick = function (event) {\n            var parentChip = this._parentChip;\n            if (parentChip.removable && !parentChip.disabled) {\n                parentChip.remove();\n            }\n            // We need to stop event propagation because otherwise the event will bubble up to the\n            // form field and cause the `onContainerClick` method to be invoked. This method would then\n            // reset the focused chip that has been focused after chip removal. Usually the parent\n            // the parent click listener of the `MatChip` would prevent propagation, but it can happen\n            // that the chip is being removed before the event bubbles up.\n            event.stopPropagation();\n        };\n        MatChipRemove.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[matChipRemove]',\n                        host: {\n                            'class': 'mat-chip-remove mat-chip-trailing-icon',\n                            '(click)': '_handleClick($event)',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChipRemove.ctorParameters = function () { return [\n            { type: MatChip },\n            { type: core.ElementRef }\n        ]; };\n        return MatChipRemove;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    /** Injection token to be used to override the default options for the chips module. */\n    var MAT_CHIPS_DEFAULT_OPTIONS = new core.InjectionToken('mat-chips-default-options');\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Boilerplate for applying mixins to MatChipList.\n    /** @docs-private */\n    var MatChipListBase = /** @class */ (function () {\n        function MatChipListBase(_defaultErrorStateMatcher, _parentForm, _parentFormGroup, \n        /** @docs-private */\n        ngControl) {\n            this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n            this._parentForm = _parentForm;\n            this._parentFormGroup = _parentFormGroup;\n            this.ngControl = ngControl;\n        }\n        return MatChipListBase;\n    }());\n    var _MatChipListMixinBase = core$1.mixinErrorState(MatChipListBase);\n    // Increasing integer for generating unique ids for chip-list components.\n    var nextUniqueId = 0;\n    /** Change event object that is emitted when the chip list value has changed. */\n    var MatChipListChange = /** @class */ (function () {\n        function MatChipListChange(\n        /** Chip list that emitted the event. */\n        source, \n        /** Value of the chip list when the event was emitted. */\n        value) {\n            this.source = source;\n            this.value = value;\n        }\n        return MatChipListChange;\n    }());\n    /**\n     * A material design chips component (named ChipList for its similarity to the List component).\n     */\n    var MatChipList = /** @class */ (function (_super) {\n        tslib.__extends(MatChipList, _super);\n        function MatChipList(_elementRef, _changeDetectorRef, _dir, _parentForm, _parentFormGroup, _defaultErrorStateMatcher, \n        /** @docs-private */\n        ngControl) {\n            var _this = _super.call(this, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) || this;\n            _this._elementRef = _elementRef;\n            _this._changeDetectorRef = _changeDetectorRef;\n            _this._dir = _dir;\n            _this.ngControl = ngControl;\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            _this.controlType = 'mat-chip-list';\n            /**\n             * When a chip is destroyed, we store the index of the destroyed chip until the chips\n             * query list notifies about the update. This is necessary because we cannot determine an\n             * appropriate chip that should receive focus until the array of chips updated completely.\n             */\n            _this._lastDestroyedChipIndex = null;\n            /** Subject that emits when the component has been destroyed. */\n            _this._destroyed = new rxjs.Subject();\n            /** Uid of the chip list */\n            _this._uid = \"mat-chip-list-\" + nextUniqueId++;\n            /** Tab index for the chip list. */\n            _this._tabIndex = 0;\n            /**\n             * User defined tab index.\n             * When it is not null, use user defined tab index. Otherwise use _tabIndex\n             */\n            _this._userTabIndex = null;\n            /** Function when touched */\n            _this._onTouched = function () { };\n            /** Function when changed */\n            _this._onChange = function () { };\n            _this._multiple = false;\n            _this._compareWith = function (o1, o2) { return o1 === o2; };\n            _this._required = false;\n            _this._disabled = false;\n            /** Orientation of the chip list. */\n            _this.ariaOrientation = 'horizontal';\n            _this._selectable = true;\n            /** Event emitted when the selected chip list value has been changed by the user. */\n            _this.change = new core.EventEmitter();\n            /**\n             * Event that emits whenever the raw value of the chip-list changes. This is here primarily\n             * to facilitate the two-way binding for the `value` input.\n             * @docs-private\n             */\n            _this.valueChange = new core.EventEmitter();\n            if (_this.ngControl) {\n                _this.ngControl.valueAccessor = _this;\n            }\n            return _this;\n        }\n        Object.defineProperty(MatChipList.prototype, \"selected\", {\n            /** The array of selected chips inside chip list. */\n            get: function () {\n                return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"role\", {\n            /** The ARIA role applied to the chip list. */\n            get: function () { return this.empty ? null : 'listbox'; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"multiple\", {\n            /** Whether the user should be allowed to select multiple chips. */\n            get: function () { return this._multiple; },\n            set: function (value) {\n                this._multiple = coercion.coerceBooleanProperty(value);\n                this._syncChipsState();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"compareWith\", {\n            /**\n             * A function to compare the option values with the selected values. The first argument\n             * is a value from an option. The second is a value from the selection. A boolean\n             * should be returned.\n             */\n            get: function () { return this._compareWith; },\n            set: function (fn) {\n                this._compareWith = fn;\n                if (this._selectionModel) {\n                    // A different comparator means the selection could change.\n                    this._initializeSelection();\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"value\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._value; },\n            set: function (value) {\n                this.writeValue(value);\n                this._value = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"id\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return this._chipInput ? this._chipInput.id : this._uid;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"required\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this._required; },\n            set: function (value) {\n                this._required = coercion.coerceBooleanProperty(value);\n                this.stateChanges.next();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"placeholder\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return this._chipInput ? this._chipInput.placeholder : this._placeholder;\n            },\n            set: function (value) {\n                this._placeholder = value;\n                this.stateChanges.next();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"focused\", {\n            /** Whether any chips or the matChipInput inside of this chip-list has focus. */\n            get: function () {\n                return (this._chipInput && this._chipInput.focused) || this._hasFocusedChip();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"empty\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () {\n                return (!this._chipInput || this._chipInput.empty) && this.chips.length === 0;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"shouldLabelFloat\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return !this.empty || this.focused; },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"disabled\", {\n            /**\n             * Implemented as part of MatFormFieldControl.\n             * @docs-private\n             */\n            get: function () { return this.ngControl ? !!this.ngControl.disabled : this._disabled; },\n            set: function (value) {\n                this._disabled = coercion.coerceBooleanProperty(value);\n                this._syncChipsState();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"selectable\", {\n            /**\n             * Whether or not this chip list is selectable. When a chip list is not selectable,\n             * the selected states for all the chips inside the chip list are always ignored.\n             */\n            get: function () { return this._selectable; },\n            set: function (value) {\n                var _this = this;\n                this._selectable = coercion.coerceBooleanProperty(value);\n                if (this.chips) {\n                    this.chips.forEach(function (chip) { return chip.chipListSelectable = _this._selectable; });\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"tabIndex\", {\n            set: function (value) {\n                this._userTabIndex = value;\n                this._tabIndex = value;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipSelectionChanges\", {\n            /** Combined stream of all of the child chips' selection change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip.selectionChange; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipFocusChanges\", {\n            /** Combined stream of all of the child chips' focus change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip._onFocus; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipBlurChanges\", {\n            /** Combined stream of all of the child chips' blur change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip._onBlur; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipList.prototype, \"chipRemoveChanges\", {\n            /** Combined stream of all of the child chips' remove change events. */\n            get: function () {\n                return rxjs.merge.apply(void 0, tslib.__spread(this.chips.map(function (chip) { return chip.destroyed; })));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        MatChipList.prototype.ngAfterContentInit = function () {\n            var _this = this;\n            this._keyManager = new a11y.FocusKeyManager(this.chips)\n                .withWrap()\n                .withVerticalOrientation()\n                .withHorizontalOrientation(this._dir ? this._dir.value : 'ltr');\n            if (this._dir) {\n                this._dir.change\n                    .pipe(operators.takeUntil(this._destroyed))\n                    .subscribe(function (dir) { return _this._keyManager.withHorizontalOrientation(dir); });\n            }\n            this._keyManager.tabOut.pipe(operators.takeUntil(this._destroyed)).subscribe(function () {\n                _this._allowFocusEscape();\n            });\n            // When the list changes, re-subscribe\n            this.chips.changes.pipe(operators.startWith(null), operators.takeUntil(this._destroyed)).subscribe(function () {\n                if (_this.disabled) {\n                    // Since this happens after the content has been\n                    // checked, we need to defer it to the next tick.\n                    Promise.resolve().then(function () {\n                        _this._syncChipsState();\n                    });\n                }\n                _this._resetChips();\n                // Reset chips selected/deselected status\n                _this._initializeSelection();\n                // Check to see if we need to update our tab index\n                _this._updateTabIndex();\n                // Check to see if we have a destroyed chip and need to refocus\n                _this._updateFocusForDestroyedChips();\n                _this.stateChanges.next();\n            });\n        };\n        MatChipList.prototype.ngOnInit = function () {\n            this._selectionModel = new collections.SelectionModel(this.multiple, undefined, false);\n            this.stateChanges.next();\n        };\n        MatChipList.prototype.ngDoCheck = function () {\n            if (this.ngControl) {\n                // We need to re-evaluate this on every change detection cycle, because there are some\n                // error triggers that we can't subscribe to (e.g. parent form submissions). This means\n                // that whatever logic is in here has to be super lean or we risk destroying the performance.\n                this.updateErrorState();\n            }\n        };\n        MatChipList.prototype.ngOnDestroy = function () {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this.stateChanges.complete();\n            this._dropSubscriptions();\n        };\n        /** Associates an HTML input element with this chip list. */\n        MatChipList.prototype.registerInput = function (inputElement) {\n            this._chipInput = inputElement;\n        };\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatChipList.prototype.setDescribedByIds = function (ids) { this._ariaDescribedby = ids.join(' '); };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.writeValue = function (value) {\n            if (this.chips) {\n                this._setSelectionByValue(value, false);\n            }\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.registerOnChange = function (fn) {\n            this._onChange = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.registerOnTouched = function (fn) {\n            this._onTouched = fn;\n        };\n        // Implemented as part of ControlValueAccessor.\n        MatChipList.prototype.setDisabledState = function (isDisabled) {\n            this.disabled = isDisabled;\n            this.stateChanges.next();\n        };\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        MatChipList.prototype.onContainerClick = function (event) {\n            if (!this._originatesFromChip(event)) {\n                this.focus();\n            }\n        };\n        /**\n         * Focuses the first non-disabled chip in this chip list, or the associated input when there\n         * are no eligible chips.\n         */\n        MatChipList.prototype.focus = function (options) {\n            if (this.disabled) {\n                return;\n            }\n            // TODO: ARIA says this should focus the first `selected` chip if any are selected.\n            // Focus on first element if there's no chipInput inside chip-list\n            if (this._chipInput && this._chipInput.focused) {\n                // do nothing\n            }\n            else if (this.chips.length > 0) {\n                this._keyManager.setFirstItemActive();\n                this.stateChanges.next();\n            }\n            else {\n                this._focusInput(options);\n                this.stateChanges.next();\n            }\n        };\n        /** Attempt to focus an input if we have one. */\n        MatChipList.prototype._focusInput = function (options) {\n            if (this._chipInput) {\n                this._chipInput.focus(options);\n            }\n        };\n        /**\n         * Pass events to the keyboard manager. Available here for tests.\n         */\n        MatChipList.prototype._keydown = function (event) {\n            var target = event.target;\n            // If they are on an empty input and hit backspace, focus the last chip\n            if (event.keyCode === keycodes.BACKSPACE && this._isInputEmpty(target)) {\n                this._keyManager.setLastItemActive();\n                event.preventDefault();\n            }\n            else if (target && target.classList.contains('mat-chip')) {\n                if (event.keyCode === keycodes.HOME) {\n                    this._keyManager.setFirstItemActive();\n                    event.preventDefault();\n                }\n                else if (event.keyCode === keycodes.END) {\n                    this._keyManager.setLastItemActive();\n                    event.preventDefault();\n                }\n                else {\n                    this._keyManager.onKeydown(event);\n                }\n                this.stateChanges.next();\n            }\n        };\n        /**\n         * Check the tab index as you should not be allowed to focus an empty list.\n         */\n        MatChipList.prototype._updateTabIndex = function () {\n            // If we have 0 chips, we should not allow keyboard focus\n            this._tabIndex = this._userTabIndex || (this.chips.length === 0 ? -1 : 0);\n        };\n        /**\n         * If the amount of chips changed, we need to update the\n         * key manager state and focus the next closest chip.\n         */\n        MatChipList.prototype._updateFocusForDestroyedChips = function () {\n            // Move focus to the closest chip. If no other chips remain, focus the chip-list itself.\n            if (this._lastDestroyedChipIndex != null) {\n                if (this.chips.length) {\n                    var newChipIndex = Math.min(this._lastDestroyedChipIndex, this.chips.length - 1);\n                    this._keyManager.setActiveItem(newChipIndex);\n                }\n                else {\n                    this.focus();\n                }\n            }\n            this._lastDestroyedChipIndex = null;\n        };\n        /**\n         * Utility to ensure all indexes are valid.\n         *\n         * @param index The index to be checked.\n         * @returns True if the index is valid for our list of chips.\n         */\n        MatChipList.prototype._isValidIndex = function (index) {\n            return index >= 0 && index < this.chips.length;\n        };\n        MatChipList.prototype._isInputEmpty = function (element) {\n            if (element && element.nodeName.toLowerCase() === 'input') {\n                var input = element;\n                return !input.value;\n            }\n            return false;\n        };\n        MatChipList.prototype._setSelectionByValue = function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) { isUserInput = true; }\n            this._clearSelection();\n            this.chips.forEach(function (chip) { return chip.deselect(); });\n            if (Array.isArray(value)) {\n                value.forEach(function (currentValue) { return _this._selectValue(currentValue, isUserInput); });\n                this._sortValues();\n            }\n            else {\n                var correspondingChip = this._selectValue(value, isUserInput);\n                // Shift focus to the active item. Note that we shouldn't do this in multiple\n                // mode, because we don't know what chip the user interacted with last.\n                if (correspondingChip) {\n                    if (isUserInput) {\n                        this._keyManager.setActiveItem(correspondingChip);\n                    }\n                }\n            }\n        };\n        /**\n         * Finds and selects the chip based on its value.\n         * @returns Chip that has the corresponding value.\n         */\n        MatChipList.prototype._selectValue = function (value, isUserInput) {\n            var _this = this;\n            if (isUserInput === void 0) { isUserInput = true; }\n            var correspondingChip = this.chips.find(function (chip) {\n                return chip.value != null && _this._compareWith(chip.value, value);\n            });\n            if (correspondingChip) {\n                isUserInput ? correspondingChip.selectViaInteraction() : correspondingChip.select();\n                this._selectionModel.select(correspondingChip);\n            }\n            return correspondingChip;\n        };\n        MatChipList.prototype._initializeSelection = function () {\n            var _this = this;\n            // Defer setting the value in order to avoid the \"Expression\n            // has changed after it was checked\" errors from Angular.\n            Promise.resolve().then(function () {\n                if (_this.ngControl || _this._value) {\n                    _this._setSelectionByValue(_this.ngControl ? _this.ngControl.value : _this._value, false);\n                    _this.stateChanges.next();\n                }\n            });\n        };\n        /**\n         * Deselects every chip in the list.\n         * @param skip Chip that should not be deselected.\n         */\n        MatChipList.prototype._clearSelection = function (skip) {\n            this._selectionModel.clear();\n            this.chips.forEach(function (chip) {\n                if (chip !== skip) {\n                    chip.deselect();\n                }\n            });\n            this.stateChanges.next();\n        };\n        /**\n         * Sorts the model values, ensuring that they keep the same\n         * order that they have in the panel.\n         */\n        MatChipList.prototype._sortValues = function () {\n            var _this = this;\n            if (this._multiple) {\n                this._selectionModel.clear();\n                this.chips.forEach(function (chip) {\n                    if (chip.selected) {\n                        _this._selectionModel.select(chip);\n                    }\n                });\n                this.stateChanges.next();\n            }\n        };\n        /** Emits change event to set the model value. */\n        MatChipList.prototype._propagateChanges = function (fallbackValue) {\n            var valueToEmit = null;\n            if (Array.isArray(this.selected)) {\n                valueToEmit = this.selected.map(function (chip) { return chip.value; });\n            }\n            else {\n                valueToEmit = this.selected ? this.selected.value : fallbackValue;\n            }\n            this._value = valueToEmit;\n            this.change.emit(new MatChipListChange(this, valueToEmit));\n            this.valueChange.emit(valueToEmit);\n            this._onChange(valueToEmit);\n            this._changeDetectorRef.markForCheck();\n        };\n        /** When blurred, mark the field as touched when focus moved outside the chip list. */\n        MatChipList.prototype._blur = function () {\n            var _this = this;\n            if (!this._hasFocusedChip()) {\n                this._keyManager.setActiveItem(-1);\n            }\n            if (!this.disabled) {\n                if (this._chipInput) {\n                    // If there's a chip input, we should check whether the focus moved to chip input.\n                    // If the focus is not moved to chip input, mark the field as touched. If the focus moved\n                    // to chip input, do nothing.\n                    // Timeout is needed to wait for the focus() event trigger on chip input.\n                    setTimeout(function () {\n                        if (!_this.focused) {\n                            _this._markAsTouched();\n                        }\n                    });\n                }\n                else {\n                    // If there's no chip input, then mark the field as touched.\n                    this._markAsTouched();\n                }\n            }\n        };\n        /** Mark the field as touched */\n        MatChipList.prototype._markAsTouched = function () {\n            this._onTouched();\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        };\n        /**\n         * Removes the `tabindex` from the chip list and resets it back afterwards, allowing the\n         * user to tab out of it. This prevents the list from capturing focus and redirecting\n         * it back to the first chip, creating a focus trap, if it user tries to tab away.\n         */\n        MatChipList.prototype._allowFocusEscape = function () {\n            var _this = this;\n            if (this._tabIndex !== -1) {\n                this._tabIndex = -1;\n                setTimeout(function () {\n                    _this._tabIndex = _this._userTabIndex || 0;\n                    _this._changeDetectorRef.markForCheck();\n                });\n            }\n        };\n        MatChipList.prototype._resetChips = function () {\n            this._dropSubscriptions();\n            this._listenToChipsFocus();\n            this._listenToChipsSelection();\n            this._listenToChipsRemoved();\n        };\n        MatChipList.prototype._dropSubscriptions = function () {\n            if (this._chipFocusSubscription) {\n                this._chipFocusSubscription.unsubscribe();\n                this._chipFocusSubscription = null;\n            }\n            if (this._chipBlurSubscription) {\n                this._chipBlurSubscription.unsubscribe();\n                this._chipBlurSubscription = null;\n            }\n            if (this._chipSelectionSubscription) {\n                this._chipSelectionSubscription.unsubscribe();\n                this._chipSelectionSubscription = null;\n            }\n            if (this._chipRemoveSubscription) {\n                this._chipRemoveSubscription.unsubscribe();\n                this._chipRemoveSubscription = null;\n            }\n        };\n        /** Listens to user-generated selection events on each chip. */\n        MatChipList.prototype._listenToChipsSelection = function () {\n            var _this = this;\n            this._chipSelectionSubscription = this.chipSelectionChanges.subscribe(function (event) {\n                event.source.selected\n                    ? _this._selectionModel.select(event.source)\n                    : _this._selectionModel.deselect(event.source);\n                // For single selection chip list, make sure the deselected value is unselected.\n                if (!_this.multiple) {\n                    _this.chips.forEach(function (chip) {\n                        if (!_this._selectionModel.isSelected(chip) && chip.selected) {\n                            chip.deselect();\n                        }\n                    });\n                }\n                if (event.isUserInput) {\n                    _this._propagateChanges();\n                }\n            });\n        };\n        /** Listens to user-generated selection events on each chip. */\n        MatChipList.prototype._listenToChipsFocus = function () {\n            var _this = this;\n            this._chipFocusSubscription = this.chipFocusChanges.subscribe(function (event) {\n                var chipIndex = _this.chips.toArray().indexOf(event.chip);\n                if (_this._isValidIndex(chipIndex)) {\n                    _this._keyManager.updateActiveItem(chipIndex);\n                }\n                _this.stateChanges.next();\n            });\n            this._chipBlurSubscription = this.chipBlurChanges.subscribe(function () {\n                _this._blur();\n                _this.stateChanges.next();\n            });\n        };\n        MatChipList.prototype._listenToChipsRemoved = function () {\n            var _this = this;\n            this._chipRemoveSubscription = this.chipRemoveChanges.subscribe(function (event) {\n                var chip = event.chip;\n                var chipIndex = _this.chips.toArray().indexOf(event.chip);\n                // In case the chip that will be removed is currently focused, we temporarily store\n                // the index in order to be able to determine an appropriate sibling chip that will\n                // receive focus.\n                if (_this._isValidIndex(chipIndex) && chip._hasFocus) {\n                    _this._lastDestroyedChipIndex = chipIndex;\n                }\n            });\n        };\n        /** Checks whether an event comes from inside a chip element. */\n        MatChipList.prototype._originatesFromChip = function (event) {\n            var currentElement = event.target;\n            while (currentElement && currentElement !== this._elementRef.nativeElement) {\n                if (currentElement.classList.contains('mat-chip')) {\n                    return true;\n                }\n                currentElement = currentElement.parentElement;\n            }\n            return false;\n        };\n        /** Checks whether any of the chips is focused. */\n        MatChipList.prototype._hasFocusedChip = function () {\n            return this.chips.some(function (chip) { return chip._hasFocus; });\n        };\n        /** Syncs the list's state with the individual chips. */\n        MatChipList.prototype._syncChipsState = function () {\n            var _this = this;\n            if (this.chips) {\n                this.chips.forEach(function (chip) {\n                    chip.disabled = _this._disabled;\n                    chip._chipListMultiple = _this.multiple;\n                });\n            }\n        };\n        MatChipList.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'mat-chip-list',\n                        template: \"<div class=\\\"mat-chip-list-wrapper\\\"><ng-content></ng-content></div>\",\n                        exportAs: 'matChipList',\n                        host: {\n                            '[attr.tabindex]': 'disabled ? null : _tabIndex',\n                            '[attr.aria-describedby]': '_ariaDescribedby || null',\n                            '[attr.aria-required]': 'role ? required : null',\n                            '[attr.aria-disabled]': 'disabled.toString()',\n                            '[attr.aria-invalid]': 'errorState',\n                            '[attr.aria-multiselectable]': 'multiple',\n                            '[attr.role]': 'role',\n                            '[class.mat-chip-list-disabled]': 'disabled',\n                            '[class.mat-chip-list-invalid]': 'errorState',\n                            '[class.mat-chip-list-required]': 'required',\n                            '[attr.aria-orientation]': 'ariaOrientation',\n                            'class': 'mat-chip-list',\n                            '(focus)': 'focus()',\n                            '(blur)': '_blur()',\n                            '(keydown)': '_keydown($event)',\n                            '[id]': '_uid',\n                        },\n                        providers: [{ provide: formField.MatFormFieldControl, useExisting: MatChipList }],\n                        encapsulation: core.ViewEncapsulation.None,\n                        changeDetection: core.ChangeDetectionStrategy.OnPush,\n                        styles: [\".mat-chip{position:relative;box-sizing:border-box;-webkit-tap-highlight-color:transparent;transform:translateZ(0);border:none;-webkit-appearance:none;-moz-appearance:none}.mat-standard-chip{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);display:inline-flex;padding:7px 12px;border-radius:16px;align-items:center;cursor:default;min-height:32px;height:1px}._mat-animation-noopable.mat-standard-chip{transition:none;animation:none}.mat-standard-chip .mat-chip-remove.mat-icon{width:18px;height:18px}.mat-standard-chip::after{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:inherit;opacity:0;content:\\\"\\\";pointer-events:none;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-standard-chip:hover::after{opacity:.12}.mat-standard-chip:focus{outline:none}.mat-standard-chip:focus::after{opacity:.16}.cdk-high-contrast-active .mat-standard-chip{outline:solid 1px}.cdk-high-contrast-active .mat-standard-chip:focus{outline:dotted 2px}.mat-standard-chip.mat-chip-disabled::after{opacity:0}.mat-standard-chip.mat-chip-disabled .mat-chip-remove,.mat-standard-chip.mat-chip-disabled .mat-chip-trailing-icon{cursor:default}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar,.mat-standard-chip.mat-chip-with-avatar{padding-top:0;padding-bottom:0}.mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-right:8px;padding-left:0}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon.mat-chip-with-avatar{padding-left:8px;padding-right:0}.mat-standard-chip.mat-chip-with-trailing-icon{padding-top:7px;padding-bottom:7px;padding-right:8px;padding-left:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-trailing-icon{padding-left:8px;padding-right:12px}.mat-standard-chip.mat-chip-with-avatar{padding-left:0;padding-right:12px}[dir=rtl] .mat-standard-chip.mat-chip-with-avatar{padding-right:0;padding-left:12px}.mat-standard-chip .mat-chip-avatar{width:24px;height:24px;margin-right:8px;margin-left:4px}[dir=rtl] .mat-standard-chip .mat-chip-avatar{margin-left:8px;margin-right:4px}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{width:18px;height:18px;cursor:pointer}.mat-standard-chip .mat-chip-remove,.mat-standard-chip .mat-chip-trailing-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-standard-chip .mat-chip-remove,[dir=rtl] .mat-standard-chip .mat-chip-trailing-icon{margin-right:8px;margin-left:0}.mat-chip-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit;overflow:hidden}.mat-chip-list-wrapper{display:flex;flex-direction:row;flex-wrap:wrap;align-items:center;margin:-4px}.mat-chip-list-wrapper input.mat-input-element,.mat-chip-list-wrapper .mat-standard-chip{margin:4px}.mat-chip-list-stacked .mat-chip-list-wrapper{flex-direction:column;align-items:flex-start}.mat-chip-list-stacked .mat-chip-list-wrapper .mat-standard-chip{width:100%}.mat-chip-avatar{border-radius:50%;justify-content:center;align-items:center;display:flex;overflow:hidden;object-fit:cover}input.mat-chip-input{width:150px;margin:4px;flex:1 0 150px}\\n\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        MatChipList.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: core.ChangeDetectorRef },\n            { type: bidi.Directionality, decorators: [{ type: core.Optional }] },\n            { type: forms.NgForm, decorators: [{ type: core.Optional }] },\n            { type: forms.FormGroupDirective, decorators: [{ type: core.Optional }] },\n            { type: core$1.ErrorStateMatcher },\n            { type: forms.NgControl, decorators: [{ type: core.Optional }, { type: core.Self }] }\n        ]; };\n        MatChipList.propDecorators = {\n            errorStateMatcher: [{ type: core.Input }],\n            multiple: [{ type: core.Input }],\n            compareWith: [{ type: core.Input }],\n            value: [{ type: core.Input }],\n            required: [{ type: core.Input }],\n            placeholder: [{ type: core.Input }],\n            disabled: [{ type: core.Input }],\n            ariaOrientation: [{ type: core.Input, args: ['aria-orientation',] }],\n            selectable: [{ type: core.Input }],\n            tabIndex: [{ type: core.Input }],\n            change: [{ type: core.Output }],\n            valueChange: [{ type: core.Output }],\n            chips: [{ type: core.ContentChildren, args: [MatChip, {\n                            // We need to use `descendants: true`, because Ivy will no longer match\n                            // indirect descendants if it's left as false.\n                            descendants: true\n                        },] }]\n        };\n        return MatChipList;\n    }(_MatChipListMixinBase));\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    // Increasing integer for generating unique ids.\n    var nextUniqueId$1 = 0;\n    /**\n     * Directive that adds chip-specific behaviors to an input element inside `<mat-form-field>`.\n     * May be placed inside or outside of an `<mat-chip-list>`.\n     */\n    var MatChipInput = /** @class */ (function () {\n        function MatChipInput(_elementRef, _defaultOptions) {\n            this._elementRef = _elementRef;\n            this._defaultOptions = _defaultOptions;\n            /** Whether the control is focused. */\n            this.focused = false;\n            this._addOnBlur = false;\n            /**\n             * The list of key codes that will trigger a chipEnd event.\n             *\n             * Defaults to `[ENTER]`.\n             */\n            this.separatorKeyCodes = this._defaultOptions.separatorKeyCodes;\n            /** Emitted when a chip is to be added. */\n            this.chipEnd = new core.EventEmitter();\n            /** The input's placeholder text. */\n            this.placeholder = '';\n            /** Unique id for the input. */\n            this.id = \"mat-chip-list-input-\" + nextUniqueId$1++;\n            this._disabled = false;\n            this._inputElement = this._elementRef.nativeElement;\n        }\n        Object.defineProperty(MatChipInput.prototype, \"chipList\", {\n            /** Register input for chip list */\n            set: function (value) {\n                if (value) {\n                    this._chipList = value;\n                    this._chipList.registerInput(this);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"addOnBlur\", {\n            /**\n             * Whether or not the chipEnd event will be emitted when the input is blurred.\n             */\n            get: function () { return this._addOnBlur; },\n            set: function (value) { this._addOnBlur = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"disabled\", {\n            /** Whether the input is disabled. */\n            get: function () { return this._disabled || (this._chipList && this._chipList.disabled); },\n            set: function (value) { this._disabled = coercion.coerceBooleanProperty(value); },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(MatChipInput.prototype, \"empty\", {\n            /** Whether the input is empty. */\n            get: function () { return !this._inputElement.value; },\n            enumerable: true,\n            configurable: true\n        });\n        MatChipInput.prototype.ngOnChanges = function () {\n            this._chipList.stateChanges.next();\n        };\n        /** Utility method to make host definition/tests more clear. */\n        MatChipInput.prototype._keydown = function (event) {\n            // Allow the user's focus to escape when they're tabbing forward. Note that we don't\n            // want to do this when going backwards, because focus should go back to the first chip.\n            if (event && event.keyCode === keycodes.TAB && !keycodes.hasModifierKey(event, 'shiftKey')) {\n                this._chipList._allowFocusEscape();\n            }\n            this._emitChipEnd(event);\n        };\n        /** Checks to see if the blur should emit the (chipEnd) event. */\n        MatChipInput.prototype._blur = function () {\n            if (this.addOnBlur) {\n                this._emitChipEnd();\n            }\n            this.focused = false;\n            // Blur the chip list if it is not focused\n            if (!this._chipList.focused) {\n                this._chipList._blur();\n            }\n            this._chipList.stateChanges.next();\n        };\n        MatChipInput.prototype._focus = function () {\n            this.focused = true;\n            this._chipList.stateChanges.next();\n        };\n        /** Checks to see if the (chipEnd) event needs to be emitted. */\n        MatChipInput.prototype._emitChipEnd = function (event) {\n            if (!this._inputElement.value && !!event) {\n                this._chipList._keydown(event);\n            }\n            if (!event || this._isSeparatorKey(event)) {\n                this.chipEnd.emit({ input: this._inputElement, value: this._inputElement.value });\n                if (event) {\n                    event.preventDefault();\n                }\n            }\n        };\n        MatChipInput.prototype._onInput = function () {\n            // Let chip list know whenever the value changes.\n            this._chipList.stateChanges.next();\n        };\n        /** Focuses the input. */\n        MatChipInput.prototype.focus = function (options) {\n            this._inputElement.focus(options);\n        };\n        /** Checks whether a keycode is one of the configured separators. */\n        MatChipInput.prototype._isSeparatorKey = function (event) {\n            if (keycodes.hasModifierKey(event)) {\n                return false;\n            }\n            var separators = this.separatorKeyCodes;\n            var keyCode = event.keyCode;\n            return Array.isArray(separators) ? separators.indexOf(keyCode) > -1 : separators.has(keyCode);\n        };\n        MatChipInput.decorators = [\n            { type: core.Directive, args: [{\n                        selector: 'input[matChipInputFor]',\n                        exportAs: 'matChipInput, matChipInputFor',\n                        host: {\n                            'class': 'mat-chip-input mat-input-element',\n                            '(keydown)': '_keydown($event)',\n                            '(blur)': '_blur()',\n                            '(focus)': '_focus()',\n                            '(input)': '_onInput()',\n                            '[id]': 'id',\n                            '[attr.disabled]': 'disabled || null',\n                            '[attr.placeholder]': 'placeholder || null',\n                            '[attr.aria-invalid]': '_chipList && _chipList.ngControl ? _chipList.ngControl.invalid : null',\n                            '[attr.aria-required]': '_chipList && _chipList.required || null',\n                        }\n                    },] }\n        ];\n        /** @nocollapse */\n        MatChipInput.ctorParameters = function () { return [\n            { type: core.ElementRef },\n            { type: undefined, decorators: [{ type: core.Inject, args: [MAT_CHIPS_DEFAULT_OPTIONS,] }] }\n        ]; };\n        MatChipInput.propDecorators = {\n            chipList: [{ type: core.Input, args: ['matChipInputFor',] }],\n            addOnBlur: [{ type: core.Input, args: ['matChipInputAddOnBlur',] }],\n            separatorKeyCodes: [{ type: core.Input, args: ['matChipInputSeparatorKeyCodes',] }],\n            chipEnd: [{ type: core.Output, args: ['matChipInputTokenEnd',] }],\n            placeholder: [{ type: core.Input }],\n            id: [{ type: core.Input }],\n            disabled: [{ type: core.Input }]\n        };\n        return MatChipInput;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n    var CHIP_DECLARATIONS = [\n        MatChipList,\n        MatChip,\n        MatChipInput,\n        MatChipRemove,\n        MatChipAvatar,\n        MatChipTrailingIcon,\n    ];\n    var Éµ0 = {\n        separatorKeyCodes: [keycodes.ENTER]\n    };\n    var MatChipsModule = /** @class */ (function () {\n        function MatChipsModule() {\n        }\n        MatChipsModule.decorators = [\n            { type: core.NgModule, args: [{\n                        exports: CHIP_DECLARATIONS,\n                        declarations: CHIP_DECLARATIONS,\n                        providers: [\n                            core$1.ErrorStateMatcher,\n                            {\n                                provide: MAT_CHIPS_DEFAULT_OPTIONS,\n                                useValue: Éµ0\n                            }\n                        ]\n                    },] }\n        ];\n        return MatChipsModule;\n    }());\n\n    /**\n     * @license\n     * Copyright Google LLC All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n    /**\n     * Generated bundle index. Do not edit.\n     */\n\n    exports.MAT_CHIPS_DEFAULT_OPTIONS = MAT_CHIPS_DEFAULT_OPTIONS;\n    exports.MatChip = MatChip;\n    exports.MatChipAvatar = MatChipAvatar;\n    exports.MatChipInput = MatChipInput;\n    exports.MatChipList = MatChipList;\n    exports.MatChipListChange = MatChipListChange;\n    exports.MatChipRemove = MatChipRemove;\n    exports.MatChipSelectionChange = MatChipSelectionChange;\n    exports.MatChipTrailingIcon = MatChipTrailingIcon;\n    exports.MatChipsModule = MatChipsModule;\n    exports.Éµ0 = Éµ0;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=material-chips.umd.js.map\n"]}